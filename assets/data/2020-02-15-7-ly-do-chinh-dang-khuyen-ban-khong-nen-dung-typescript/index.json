{"hash":"3274fa32f48b39b818211d541fbcf5a00b3e3bc4","data":{"post":{"title":"7 lý do bạn không nên sử dụng TypeScript","path":"/2020-02-15-7-ly-do-chinh-dang-khuyen-ban-khong-nen-dung-typescript/","date":"2020-02-15","timeToRead":4,"tags":[{"id":"dam-dao","title":"dam-dao","path":"/tag/dam-dao/"},{"id":"javascript","title":"javascript","path":"/tag/javascript/"},{"id":"typescript","title":"typescript","path":"/tag/typescript/"}],"desc":"TypeScript có phải là con ác chủ bài, ngôn ngữ của tương lai, viết TypeScript thì mọi thứ sẽ không thể nào còn lỗi, những lý do khiến bạn phải suy nghĩ lại những nhận định trên","content":"<!-- TOC -->\n<ul>\n<li><a href=\"#qu%C3%A1-m%E1%BA%A1o-hi%E1%BB%83m\">Quá mạo hiểm</a></li>\n<li><a href=\"#qu%C3%A1-r%E1%BB%91i-r%E1%BA%AFm\">Quá rối rắm</a></li>\n<li><a href=\"#kh%C3%B4ng-gi%E1%BA%A3i-quy%E1%BA%BFt-v%E1%BA%A5n-%C4%91%E1%BB%81\">Không giải quyết vấn đề</a></li>\n<li><a href=\"#ch%E1%BA%B3ng-thay-th%E1%BA%BF-ch%E1%BB%89-l%C3%A0-ph%E1%BA%A7n-m%E1%BB%9F-r%E1%BB%99ng\">Chẳng thay thế, chỉ là phần mở rộng</a></li>\n<li><a href=\"#m%C3%A3-ngu%E1%BB%93n-m%E1%BB%9F-c%C3%B3-th%E1%BA%ADt-v%E1%BA%ADy-kh%C3%B4ng\">Mã nguồn mở, có thật vậy không?</a></li>\n<li><a href=\"#c%C3%A1c-c%C3%B4ng-ty-l%E1%BB%9Bn-s%E1%BB%AD-d%E1%BB%A5ng\">Các công ty lớn sử dụng...</a></li>\n<li><a href=\"#nhi%E1%BB%81u-t%C3%ADnh-n%C4%83ng-h%C6%A1n\">Nhiều tính năng hơn</a></li>\n</ul>\n<!-- /TOC -->\n<p>Rất nhiều người yêu TypeScript, nó <em>\"giải quyết\"</em> rất nhiều vấn đề mà JS gặp phải, một ngôn ngữ <em>\"thay thế\"</em> cho JS, nó sẽ báo bạn ngay nếu code bạn có <em>vấn đề</em> và <em>dễ đọc</em> hơn. Có nhiều nhiều lý do được đưa ra để bạn nên dùng TypeScript, bài này ngược lại đưa cho bạn 7 lý do không nên dùng TypeScript</p>\n<h2 id=\"quá-mạo-hiểm\"><a href=\"#qu%C3%A1-m%E1%BA%A1o-hi%E1%BB%83m\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Quá mạo hiểm</h2>\n<p>Tại sao lại mạo hiểm? Nếu TypeScript thêm định nghĩa type và kiểm tra lúc compile, IDE còn thông báo ngay lúc nếu kiểu dữ liệu không khớp. Chính xác đó là lý do. TypeScript chỉ kiểm tra kiểu dữ liệu lúc compile và <em>chỉ</em> sử dụng kiểu có định nghĩa. Tất cả các network call, API và thư viện bổ sung chưa có type sẽ không có cách nào tương tác với TypeScript.</p>\n<p>Nếu trong JS, chúng ta không đặt giả định về kiểu sẽ nhận được, không tự nhủ \"cái này chắc chắn\" sẽ trả về kiểu <code class=\"language-text\">string</code>, chúng ta luôn biết phải kiểm tra giá trị thật sự của biến nhận được trước khi sử dụng. Với TS, bạn phụ thuộc compiler làm việc này, nhưng sẽ có rất nhiều thứ phải làm. Bạn vừa phải bỏ thời gian viết định nghĩa cho từng tỉ tỉ thứ, rồi bỏ thêm mớ thời gian để đảm bảo các định nghĩa bạn viết ra phải đúng lúc chạy, vậy mục tiêu cuối cùng của tất cả những thứ đó là gì?</p>\n<h2 id=\"quá-rối-rắm\"><a href=\"#qu%C3%A1-r%E1%BB%91i-r%E1%BA%AFm\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Quá rối rắm</h2>\n<p>Mặt trái của sự thật: một ngôn ngữ được kỳ vọng sẽ đem đến sự minh bạch, sạch sẽ, dễ đọc hơn lại đem đến điều người lại. Để minh họa, hãy nhìn thử một đoạn TS sau</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// TODO: do this more elegantly</span>\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>currentReducer <span class=\"token keyword\">as</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> Reducer<span class=\"token operator\">&lt;</span>NewState<span class=\"token punctuation\">,</span>NewActions<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> nextReducer\n\n<span class=\"token keyword\">static</span> create<span class=\"token operator\">:</span> <span class=\"token builtin\">Function</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>subscribe<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>subscriber<span class=\"token operator\">:</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> TeardownLogic<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Observable<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span>subscribe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Đóng code trên lấy từ thư viện Redux và RxJS. Nếu bạn đang viết React và thích HOC, thì bạn sẽ hiểu viết bổ sung TypeScript sẽ đem đến mồ hôi và nước mắt cho các đồng nghiệp khác như thế nào.</p>\n<h2 id=\"không-giải-quyết-vấn-đề\"><a href=\"#kh%C3%B4ng-gi%E1%BA%A3i-quy%E1%BA%BFt-v%E1%BA%A5n-%C4%91%E1%BB%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Không giải quyết vấn đề</h2>\n<p>TS bảo là giải quyết các vấn đề mà JS đang gặp. Nhưng sự thật là KHÔNG. Dynamic typing chưa bao giờ là vấn đề với những lập trình viên JS (có mình luôn), bạn sẽ phàn nàn vậy \"NaN === NaN\" không phải là vấn đề sau, việc có cũng được không có cũng được dấu chấm phẩy <code class=\"language-text\">;</code> không phải là vấn đề à,... một vài lý do khác nữa. TypeScript cũng chẳng giải quyết như bạn tưởng tượng đâu, nó chỉ giới thiệu một chuẩn mới, làm phân cực công đồng JS thêm thôi.</p>\n<p>Thậm chí, nếu việc thiếu type trong JS là một vấn đề, TS không giải quyết luôn. Những ngôn ngữ thật sự giải quyết nó là Java, C, C# và các ngôn ngữ <code class=\"language-text\">compiled</code>.</p>\n<h2 id=\"chẳng-thay-thế-chỉ-là-phần-mở-rộng\"><a href=\"#ch%E1%BA%B3ng-thay-th%E1%BA%BF-ch%E1%BB%89-l%C3%A0-ph%E1%BA%A7n-m%E1%BB%9F-r%E1%BB%99ng\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Chẳng thay thế, chỉ là phần mở rộng</h2>\n<p>TS sau cùng cũng complie về JS, nó không hề là <strong>một ngôn ngữ có thể thay thế</strong> JS như tự sướng. Những gì TypeScript có thể làm, sẽ bị giới hạn trong những gì JS làm được. Đừng ảo tưởng với TS là bạn đã đủ chinh chiến trên mọi chiến trường, đừng tin vào lời dối trá đó, hãy tìm hiểu nhiều hơn sức mạnh thực sự của JS và linh động kiểu dữ liệu mang lại gì cho bạn, lúc đó bạn sẽ thấy mình đã tiến xa hơn những gì cái khung TS đã đóng bạn lại.</p>\n<h2 id=\"mã-nguồn-mở-có-thật-vậy-không\"><a href=\"#m%C3%A3-ngu%E1%BB%93n-m%E1%BB%9F-c%C3%B3-th%E1%BA%ADt-v%E1%BA%ADy-kh%C3%B4ng\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Mã nguồn mở, có thật vậy không?</h2>\n<p>Nhiều lý do đưa ra khi sử dụng TS là vì nó mã nguồn mở. Đúng, nhưng chưa đủ. Nó vẫn chịu sự chi phối từ Microsoft, một tập đoàn độc quyền khổng lồ nổi tiếng nhất thế giới, Microsoft chia sẻ mã nguồn nó như một động thái tiếp thị và lôi kéo thêm lập trình viên. Đừng lẫn lộn giữa mã nguồn mở với sự dân chủ: Microsoft vẫn ở đây và có quyền làm mọi thứ với TS, bạn chẳng làm gì được ngoài việc đứng nhìn. JS, lại khác, được cộng đồng đảm trách, sẽ không thay đổi bất cứ thứ gì nếu không được sự đồng ý từ số đông cộng đồng.</p>\n<h2 id=\"các-công-ty-lớn-sử-dụng\"><a href=\"#c%C3%A1c-c%C3%B4ng-ty-l%E1%BB%9Bn-s%E1%BB%AD-d%E1%BB%A5ng\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Các công ty lớn sử dụng...</h2>\n<p>Không ít các cá nhân có trách nhiệm lựa chọn ngôn ngữ cho dự án lại đưa đây làm một lý do để sử dụng TS. Vậy có tính đến chuyện các công ty lớn cũng có những bộ codebase cũ mèm, lỗi thời. Việc người khác chọn một thứ gì đó, chắc gì thứ đó cũng hợp với mình.</p>\n<h2 id=\"nhiều-tính-năng-hơn\"><a href=\"#nhi%E1%BB%81u-t%C3%ADnh-n%C4%83ng-h%C6%A1n\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nhiều tính năng hơn</h2>\n<p>Xưa rồi, khi TS được giới thiệu năm 2012, các tính năng như <code class=\"language-text\">class</code> chưa có trên JS. Nhưng nay đã là 2020, hơn 8 năm nay, JS đã tiến một bước rất xa, phải nói đúng hơn là giờ TS còn phải chạy theo JS</p>\n<p>Từ quan điểm của một cá nhân không thấy nhiều lợi ích mà TypeScript mang lại.</p>\n<p><a href=\"https://everyday.codes/javascript/7-really-good-reasons-not-to-use-typescript/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">7 really good reasons not to use TypeScript</a></p>\n","cover_image":"","related":[{"id":"9d87d27381e3669ee806ffebb81e98ed","path":"/2019-10-25-gioi-thieu-javascript-khong-dung-jquery/","title":"Bạn không cần jQuery","desc":"Không cần jQuery, bạn thể thể dùng javascript thuần để thực hiện những thao tác trước đây bạn nghĩ phải có jQuery cơ"},{"id":"399b91323d4985064172d8d9c1bb57c4","path":"/2020-05-17-functional-programing-nen-va-khong-nen/","title":"Functional programing nên và không nên","desc":""},{"id":"e48f241d053eb1fd1df12d270dc6c371","path":"/2020-01-02-khi-nao-nen-su-dung-uselayouteffect-trong-react/","title":"Khi nào nên sử dụng useLayoutEffect thay vì useEffect","desc":"2 React Hook làm nhiệm vụ khá giống nhau là useEffect và useLayoutEffect bạn đã biết cách sử dụng thế nào cho đúng"},{"id":"2bda1aea7bf5ac181ed1d3a656b277f5","path":"/2020-10-26-huong-dan-su-dung-usememo-react/","title":"Hướng dẫn sử dụng useMemo trong React","desc":"Nếu bạn thấy app của mình bắt đầu chậm, đó là lúc bạn nên bắt đầu cân nhắc các phương pháp để tối ưu tốc độ và đọc bài viết này."}]}},"context":{}}