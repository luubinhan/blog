{"hash":"6f8620c4b9320834772a34e00598bbfeaacfb63b","data":{"post":{"title":"Nguyên lý nền tảng của lập trình function","path":"/nguyen-ly-nen-tang-cua-lap-trinh-function/","slug":"/2019-07-26-nguyen-ly-chung-cua-lap-trinh-huong-function","date":"2019-07-26","timeToRead":6,"tags":[{"id":"javascript","title":"javascript","path":"/tag/javascript/"},{"id":"hoc-thuat","title":"hoc-thuat","path":"/tag/hoc-thuat/"}],"desc":"Khái niệm ngàn người biết, bạn cũng phải biết","content":"<!-- TOC -->\n<ul>\n<li><a href=\"#n%c3%b3i-v%e1%bb%81-l%e1%bb%a3i-%c3%adch\">Nói về lợi ích</a></li>\n<li><a href=\"#immutable\">Immutable</a></li>\n<li><a href=\"#pure-function\">Pure Function</a></li>\n<li><a href=\"#%c4%90%e1%bb%87-quy\">Đệ quy</a></li>\n<li><a href=\"#t%e1%bb%95ng-k%e1%ba%bft\">Tổng kết</a></li>\n<li><a href=\"#t%c3%a0i-li%e1%bb%87u-tham-kh%e1%ba%a3o\">Tài liệu tham khảo</a></li>\n</ul>\n<!-- /TOC -->\n<h2 id=\"nói-về-lợi-ích\"><a href=\"#n%C3%B3i-v%E1%BB%81-l%E1%BB%A3i-%C3%ADch\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nói về lợi ích</h2>\n<p>Trước tiên chúng ta phải nói về lợi ích của kiểu lập trình hướng function, để có thể có động lực <em>nghiên cứu đào sâu</em>, một vài điểm được nhiều người thống nhất</p>\n<p>Code của chúng ta trở nên \"module\" hơn, nhắc về module thì lấy ví dụ trò xếp hình là dễ hình dung nhất</p>\n<p><img src=\"https://cdn.redshift.autodesk.com/2014/10/benefits_of_modular_construction_lego.jpg\" alt=\"Minh họa Module\"></p>\n<ul>\n<li>Các function độc lập, khi kết nối với nhau tạo ra một chương trình\nModule cũng sẽ giúp code dễ hiểu hơn, 1 function = 1 công dụng, <em>không có gì dấu diếm</em></li>\n<li>Dễ copy/paste hơn</li>\n<li>Dễ test hơn</li>\n</ul>\n<p>Bên dưới chúng ta sẽ đề cập đến những nguyên lý nền tảng, mà kinh nghiệm thực tế đúc kết được, như sử dụng <strong>immutable</strong> thay vì <strong>mutable</strong>, viết <strong>pure function</strong>, chia nhỏ bằng đệ quy, là những <strong>nguyên lý</strong> nền tảng, không ám chỉ một ngôn ngữ cụ thể nào</p>\n<h2 id=\"immutable-sống-kiên-định-thủy-chung\"><a href=\"#immutable-s%E1%BB%91ng-ki%C3%AAn-%C4%91%E1%BB%8Bnh-th%E1%BB%A7y-chung\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Immutable, sống kiên định thủy chung</h2>\n<p>Nói đến lập trình function trước tiên phải nói về <strong>immutable</strong></p>\n<blockquote>\n<p>Immutable là dạng dữ liệu sau khi tạo ra thì không thay đổi nữa</p>\n</blockquote>\n<p>Mutate là gì? ví dụ, gán tham chiếu vào một biến đã có</p>\n<pre class=\"language-js{2}\"><code class=\"language-js{2}\">var x = { name: 'luckyluu' }\nvar y = x\n\nx = { name: 'vuilaptrinh' }\nconsole.log(x, y)\n// => {name: \"vuilaptrinh\"} { name: \"luckyluu\" }</code></pre>\n<p>Giá trị <code>x</code> tham chiếu đến một vùng nhớ khác khi viết <code>x = { name: 'vuilaptrinh' }</code>, trong khi đó <code>y</code> vẫn tham chiếu đến vùng nhớ cũ là <code>{ name: 'luckyluu' }</code></p>\n<p>Trường hợp 2 là chỉnh sửa giá một object có sẵn</p>\n<pre class=\"language-js{4}\"><code class=\"language-js{4}\">var x = { name: 'luckyluu' }\nvar y = x\n\nx.name = 'vuilaptrinh'\nconsole.log(x, y)\n// => {name: \"vuilaptrinh\"} { name: \"vuilaptrinh\" }</code></pre>\n<p>Không thay đổi <code>y</code>, nhưng cả 2 cùng tham chiếu tới cùng một <code>x</code>.</p>\n<p>Riêng javascript chúng ta phải dùng hẳn một thư viện <a href=\"https://immutable-js.github.io/immutable-js/docs/#/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">immutable-js</a> vì việc \"chặn\" không cho thay đổi dữ liệu trong javascript thì \"f..king complicated\", đừng nghĩ <code>const bienA</code> là đã mutable, nó chỉ thay đổi scope thôi bạn ơi</p>\n<p>Immutable là một cách làm không tốn nhiều chi phí để ngăn chặn các con bug chúng ta gặp trong các tình huống cá biệt, như 2 luồng xử lý cũng thực hiện ghi đè một giá trị-cùng lúc, hay trong một lần đọc dữ liệu nào đó mà bạn \"nhỡ tay\" đã thay đổi dữ liệu mà không hay biết.</p>\n<p>Cái gì cũng có giá của nó! Tùy vào ngôn ngữ và cục object bự cỡ nào, chi phí bỏ ra để <code>clone</code> object ban đầu để chỉnh sửa sẽ khác nhau. Phát sinh vấn đề \"xả rác\" lung tung qua việc khai báo các object mới liên tục khi cần chỉnh sửa, do đó các trường hợp phát triển GUI (viết một editor như VS Code gọi là phát triển GUI) hay game sẽ không phù hợp với immutable, tất nhiên luôn có một vài chỗ vẫn dùng được</p>\n<p>Khi bắt đầu dùng immutable, chúng ta phải tiếp cận khi viết code, phải suy nghĩ từng \"cục\" code nên làm thêm nào để <em>sạch</em> hơn, an toàn với sức khỏe bà mẹ và trẻ em hơn</p>\n<h2 id=\"pure-function-sống-nề-nếp-không-ảnh-hưởng-đến-nhà-hàng-xóm\"><a href=\"#pure-function-s%E1%BB%91ng-n%E1%BB%81-n%E1%BA%BFp-kh%C3%B4ng-%E1%BA%A3nh-h%C6%B0%E1%BB%9Fng-%C4%91%E1%BA%BFn-nh%C3%A0-h%C3%A0ng-x%C3%B3m\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Pure Function, sống nề nếp không ảnh hưởng đến nhà hàng xóm</h2>\n<p>Thế nào là một <strong>Function Sạch</strong> ?</p>\n<p>Đó giờ chúng ta vẫn viết function, lập trình hướng function thì có gì khác? <strong>function</strong> ở đây ám chỉ các hàm hoạt động như hàm toán học như <code>f(x) = x + 1</code>, những hàm toán học này rất đơn giản, nhận một giá trị, và trả về một giá trị, không chỉnh sửa giá trị bên ngoài, dù nó được truyền vào như tham số của hàm, nếu cùng tham số truyền vào, <strong>luôn luôn</strong> nhận được cùng kết quả trả về. Truyền vào cho <code>f(x) = x + 1</code> là 2 thì bất cứ lần nào cũng nhận được kết quả là 3.</p>\n<p>Nhờ vậy chúng ta có thể <strong>cache</strong> kết quả này, sử dụng kết quả cache trong trường hợp có cùng input. Chúng ta cũng có thể gọi các function này trên nhiều luồng chạy song song mà không phải lo lắng gì. Nếu các function không phụ thuộc lẫn nhau, chúng ta cũng có thể gọi nó theo bất cứ thứ tự nào mà không quan tâm đến vấn đề <strong>race condition</strong></p>\n<blockquote>\n<p>Race condition, mình giải thích nôm na thế này, bạn là chàng trai lắm em theo đuổi, người đến trước, kẻ đến sau, mức độ quyết liệt của mỗi em lại khác nhau không phụ thuộc ai trước, ai sau, em xuất phát sau quá quyết liệt, nên ngỏ lời đòi cưới trước, bạn đồng ý, sau đó em xuất phát trước, cuối cùng cũng chạy tới được nhà bạn, bạn lại đồng ý tiếp. Thế là tiêu đời bạn rồi.</p>\n</blockquote>\n<h2 id=\"đệ-quy-sống-luôn-nhớ-về-ông-bà-tổ-tiên\"><a href=\"#%C4%91%E1%BB%87-quy-s%E1%BB%91ng-lu%C3%B4n-nh%E1%BB%9B-v%E1%BB%81-%C3%B4ng-b%C3%A0-t%E1%BB%95-ti%C3%AAn\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Đệ quy, sống luôn nhớ về ông bà tổ tiên</h2>\n<p>Function gọi lại chính nó, không phụ thuộc biến đếm liên quan gì tới lập trình function?</p>\n<p>Ý tưởng cốt lõi của đệ quy là chia bài toán lớn thành bài toán tương tự như vậy, nhưng quy mô nhỏ hơn. Vấn đề nhỏ hơn nghĩa là cũng dễ hiểu hơn, cách giải quyết cũng rõ rành rành hơn. Khi chúng ta đổi mặt với vòng lặp, nghĩ xem đệ quy có phải là lựa chọn đúng hơn không. Ví dụ lặp bình thường phù hợp khi cần đi qua tất cả phần tử trong mảng, đệ quy lại phù hợp áp dụng quicksort trong mảng (thứ 6 tuần sau mình viết bài này nha!)</p>\n<p>Khi làm việc với đệ quy, luôn nhớ sử dụng và nằm lòng câu hỏi <strong>điều gì sẽ thực thi khi nó ở vị trí cuối cùng</strong></p>\n<pre class=\"language-js{6}\"><code class=\"language-js{6}\">function factorial(x, acc) {\n\tacc = acc || 1\n\tif (x > 1) {\n\t\treturn factorial(x - 1, acc * x)\n\t} else {\n\t\treturn acc\n\t}\n}</code></pre>\n<p>Hạn chế được yếu điểm của đệ quy là <strong>tràn stack</strong> với câu hỏi trên.</p>\n<h2 id=\"tổng-kết\"><a href=\"#t%E1%BB%95ng-k%E1%BA%BFt\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tổng kết</h2>\n<p>Tóm lại tại sao thiên hạ <strong>rần rần</strong> với lập trình function hâm he triệt lập trình hướng đối tượng OOP</p>\n<ul>\n<li>Không tạo ra side effect</li>\n<li>Thứ tự chạy function không quan trọng</li>\n<li>Dễ đọc (ý là người khác dễ đọc lại và hiểu mình đang viết gì)</li>\n</ul>\n<p>Tất nhiên không phải lúc nào lập trình function cũng phù hợp với bất kỳ trường hợp nào, đôi khi side effect là cần thiết, bắt buộc, bạn không thể viết toàn bộ chương trình bằng pure function</p>\n<p>Theo quan điểm cá nhân: lập trình function trở nên phổ biến bởi 2 nguyên nhân: 1. Ngày càng nhiều vi xử lý có khả năng xử lý đồng thời trên đa luồng, 2. Đây là kiểu viết rất dễ tiếp cận với mọi người (như ai cũng xài windows vì bẻ khóa nó thì không có gì dễ đến thế)</p>\n<h2 id=\"tài-liệu-tham-khảo\"><a href=\"#t%C3%A0i-li%E1%BB%87u-tham-kh%E1%BA%A3o\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tài liệu tham khảo</h2>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://www.lucidchart.com/techblog/2017/11/29/functional-programming-principles-every-imperative-programmer-should-use/\">FUNCTIONAL PROGRAMMING PRINCIPLES EVERY IMPERATIVE PROGRAMMER SHOULD USE</a></p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://stackoverflow.com/questions/36504/why-functional-languages\">Why functional languages? </a></p>\n","cover_image":"","related":[{"id":"a3122abaeff5dd1ef038b80398ff52d3","path":"/10-nguyen-ly-lap-trinh-nen-tang-ma-lap-trinh-vien-nao-cung-can-biet/","title":"10 nguyên lý lập trình nền tảng mà lập trình viên nào cũng cần biết","desc":"Nhớ thời đại học quá nên ôn lại kiến thức vở lòng mấy bạn ơi"},{"id":"65c9d6e21303c8c99eff5408a9afcf9c","path":"/goc-nhin-cua-nguoi-tuyen-dung-mot-lap-trinh-vien-react/","title":"Góc nhìn của người tuyển dụng một lập trình viên React","desc":"Trong một tương lai không xa, khi mình được đặt vào vị trí phỏng vấn các bạn Front-End, mình sẽ hỏi gì đây?"},{"id":"82094eb3a75f8e7cc086b97fe788ec2e","path":"/huong-dan-tao-mot-package-publish-no-len-npm/","title":"Hướng dẫn tạo một package, publish nó lên npm","desc":"Nếu bạn có một package nào đó muốn chia sẽ cùng mọi người trên npm, thì đây là cách bạn publish package make-by-me như vậy lên npm"},{"id":"0da94706a1e6b0e733fc6085a9118cc2","path":"/mot-so-nguyen-tac-voi-hinh-anh-responsive/","title":"Một số nguyên tắc với hình ảnh responsive","desc":"Nếu bạn đã quên hoặc chưa biết, hình tiêu tốn hơn 50% dung lượng tải trang. Responsive image tuy dễ nhưng không nên xem nhẹ"}]}},"context":{}}