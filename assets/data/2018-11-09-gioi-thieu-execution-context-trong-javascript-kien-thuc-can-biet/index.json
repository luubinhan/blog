{"hash":"0b850c1ecbd24bffff99e8513198ea7381cb23bf","data":{"post":{"title":"Tìm hiểu Execution context trong Javascript","path":"/2018-11-09-gioi-thieu-execution-context-trong-javascript-kien-thuc-can-biet/","slug":"/2018-11-09-gioi-thieu-execution-context-trong-javascript-kien-thuc-can-biet","date":"2018-11-09","timeToRead":4,"tags":[{"id":"javascript","title":"javascript","path":"/tag/javascript/"}],"desc":"Theo quan điểm của mình, khái niệm căn bản và quan trọng bật nhất của javascript là hiểu được Execution Context,","content":"<!-- TOC -->\n<ul>\n<li><a href=\"#global-execution-context\">Global Execution Context</a></li>\n<li><a href=\"#function-execution-context\">Function Execution Context</a></li>\n</ul>\n<!-- /TOC -->\n<p>Sau khi nắm được nó chúng ta có thể giải thích những vấn đề <em>cao siêu</em> như <strong>hoisting</strong>, <strong>scope chain</strong>, <strong>closure</strong>.</p>\n<p>Để hiểu Execution Context, ngẫm lại cách chúng ta viết code: chúng ta tách nó ra thành những phần nhỏ riêng biệt. Những “phần nhỏ” này có các tên gọi như function, module, package, tất cả là để chia nhỏ, dễ quản lý một mớ code vừa to vừa phức tạp.</p>\n<p>Nếu Javascript là một người thực thi các đoạn code này, nó cũng dùng cách tương tự, thực thi từng phần code một, được gọi là Execution Context</p>\n<div class=\"note\">Mỗi Execution Context sẽ có 2 phase, **Creation phase** và **Execution phase**</div>\n<p>Có 2 loại Execution Context: </p>\n<ol>\n<li>Global Execution Context</li>\n<li>Function Execution Context</li>\n</ol>\n<h2 id=\"global-execution-context\"><a href=\"#global-execution-context\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Global Execution Context</h2>\n<p>Được tạo khi javascript chạy code của chúng ta, bình thường nó sẽ tạo ra 2 thứ: 1 global object và một biến gọi là <code class=\"language-inline-text\">this</code>. <code class=\"language-inline-text\">this</code> sẽ trỏ tới global object là window nếu chạy trên trình duyệt, trỏ tới <code class=\"language-inline-text\">global</code> nếu chạy trên Node</p>\n<p><img src=\"https://ui.dev/post-images/no-code.png\" alt=\"Execution context, Hoisting, Scopes, Closures trong Javascript\"></p>\n<p>Khi chúng ta khai báo thêm biến</p>\n<p><img src=\"https://ui.dev/post-images/global-variables-in-creation-phase.png\" alt=\"Globals variables in the creation phase\">\n<img src=\"https://ui.dev/post-images/global-variables-in-execution-phase.png\" alt=\"Global variables in the execution phase\"></p>\n<p>Creation phase của Global Execution context sẽ có các bước</p>\n<ol>\n<li>Tạo global object</li>\n<li>Tạo object tên là <code class=\"language-inline-text\">this</code></li>\n<li>Setup vùng nhớ tạm thời cho biến và function</li>\n<li>Gắn giá trị <code class=\"language-inline-text\">undefined</code> cho biến, trỏ từng function đến vùng nhớ.</li>\n</ol>\n<p>Thử log giá trị sau creation phase và trước execution phase</p>\n<p><img src=\"https://ui.dev/post-images/global-execution-context-gif.gif\" alt=\"Animated GIF showing flow from creation phase to execution phase\"></p>\n<p>Trước khi javascript thực sự chạy các dòng code, <em>creation phase</em> xảy ra trước, nên giá trị log ra sẽ là <code class=\"language-inline-text\">undefined</code>, function sẽ trỏ tới một vùng nhớ.</p>\n<div class=\"gridsome-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name: '</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span> <span class=\"token comment\">// name: undefined</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'handle: '</span><span class=\"token punctuation\">,</span> handle<span class=\"token punctuation\">)</span> <span class=\"token comment\">// handle: undefined</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'getUser :'</span><span class=\"token punctuation\">,</span> getUser<span class=\"token punctuation\">)</span> <span class=\"token comment\">// getUser: ƒ getUser () {}</span>\n\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Tyler'</span>\n<span class=\"token keyword\">var</span> handle <span class=\"token operator\">=</span> <span class=\"token string\">'@tylermcginnis'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getUser</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> name<span class=\"token punctuation\">,</span>\n    handle<span class=\"token operator\">:</span> handle\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"note\">Trong creation phase, quá trình gắn các biến được khai báo vào giá trị `undefined` được gọi là **hoisting**.</div>\n<h2 id=\"function-execution-context\"><a href=\"#function-execution-context\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Function Execution Context</h2>\n<p>Được tạo ra khi thực thi hàm, cơ bản nó cũng giống với Global execution context, khác ở chỗ nó bỏ bước #1</p>\n<ol>\n<li><del>Tạo global object</del></li>\n<li>Tạo một object tên <code class=\"language-inline-text\">arguments</code></li>\n<li>Tạo object tên là <code class=\"language-inline-text\">this</code></li>\n<li>Setup vùng nhớ tạm thời cho biến và function</li>\n<li>Gắn giá trị <code class=\"language-inline-text\">undefined</code> cho biến, trỏ từng function đến vùng nhớ.</li>\n</ol>\n<p><img src=\"https://ui.dev/post-images/function-execution-context-gif.gif\" alt=\"GIF showing how a new execution context is created when a function is invoked\"></p>\n<p>Bạn có thấy cái ô màu hồng hồng trên hình nó xuất hiện khi function được thực thi, sau đó bị remove sau khi chạy xong. Khi tạo một execution context, javascript đưa vào một hàng đợi gọi là <strong>Call Stack</strong>, sau khi đã chạy xong 2 phase nó remove khỏi Call Stack</p>\n<p><img src=\"https://ui.dev/post-images/javascript-execution-stack.gif\" alt=\"sau khi đã chạy xong 2 phase nó remove khỏi Call Stack\n\"></p>\n<p><a href=\"https://goo.gl/vjmnTa\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Chạy thử</a></p>\n<p>Với một function có khai báo biến bên trong</p>\n<p><img src=\"https://ui.dev/post-images/local-variables.gif\" alt=\"Với một function có khai báo biến bên trong\"></p>\n<p>Quá hiển nhiên là biến <code class=\"language-inline-text\">handle</code> nằm trong Global Execution Context, nên bên trong function chúng ta có thể access đến nó, trong khi biến <code class=\"language-inline-text\">twitterURL</code> được khởi tạo ở trong function, nó chỉ có trong Function Execution Context khi hàm được thực thi. Đây chính là nền tảng của khái niệm <strong>SCOPE</strong></p>\n<p>Chúng ta đã biết scope ám chỉ việc biến có thể truy xuất ở đâu. Trên MDN nó định nghĩa scope</p>\n<blockquote>\n<p>Scope: The current context of execution.</p>\n</blockquote>\n<p>Giờ bạn nghĩ xem, cái gì sẽ được log ra sau khi chạy hàm</p>\n<div class=\"gridsome-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">first</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Jordyn'</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">second</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Jake'</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Tyler'</span>\n<span class=\"token function\">first</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">second</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span></code></pre></div>\n<p><img src=\"https://ui.dev/post-images/unique-scopes.gif\" alt=\"Execution context, Hoisting, Scopes, Closures\"></p>\n<p>Chúng ta sẽ có thứ tự log ra: <code class=\"language-inline-text\">undefined</code>, <code class=\"language-inline-text\">Jordyn</code>, <code class=\"language-inline-text\">Jake</code>, <code class=\"language-inline-text\">Tyler</code></p>\n<p>Trong trường hợp biến không tồn tại trong execution context của function, liệu nó sẽ log ra cái gì, hay ngừng chạy?</p>\n<div class=\"gridsome-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Tyler'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">logName</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">logName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><img src=\"https://ui.dev/post-images/parent-lookup.gif\" alt=\"Trong trường hợp biến không tồn tại trong execution context của function\"></p>\n<p>Kết quả log ra là \"Tyler\", dù bên trong execution context của hàm không có biến, nó sẽ tìm đến thằng context cha xem có giá trị của biến này chưa, cho đến khi global execution context nó sẽ dừng.</p>\n<div class=\"note\">Đặc điểm này trọng javascript được gọi là Scope chain</div>\n<p><img src=\"https://ui.dev/post-images/closure-scope.gif\" alt=\"Đặc điểm này trọng javascript được gọi là Scope chain\"></p>\n<div class=\"note\">Khi chúng ta lồng một function bên trong 1 function như vậy, nó sẽ tạo ra một cái gọi là <b>Closure Scope</b></div>\n<p>Tham khảo thêm</p>\n<p>Mình đã viết bài này trên MDN <a href=\"https://developer.mozilla.org/vi/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener noreferrer\">Closures</a></p>\n<p><a href=\"https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/\" target=\"_blank\" rel=\"noopener noreferrer\">The Ultimate Guide to Execution Contexts, Hoisting, Scopes, and Closures in JavaScript</a></p>\n<p><a href=\"https://tylermcginnis.com/javascript-visualizer/\" target=\"_blank\" rel=\"noopener noreferrer\">Diễn giải các khái niệm bằng công cụ do tác giả build </a></p>\n","cover_image":"","related":[{"id":"e1da35afe424b0fa665424514de0af1d","path":"/2018-12-19-tim-hieu-curring-function-trong-javascript/","title":"Tìm hiểu Currying function trong Javascript","desc":"Bài viết này chúng ta sẽ tìm hiểu về cái cà-ri này, nó chạy ra sao, hữu dụng thế nào."},{"id":"65395bae8cda365addbb20f99ba00455","path":"/2019-04-12-huong-dan-tim-hieu-time-zone/","title":"Tìm hiểu về Time Zone","desc":"Cùng luận bàn những vấn đề liên quan đến time zone"},{"id":"1ae2a37d4f8455d37c67ec40ca86232b","path":"/2020-08-14-tim-hieu-phuong-thuc-slice-trong-javascript/","title":"Tìm hiểu phương thức slice của mảng trong javascript","desc":"Bài viết phù họp cho các bạn mới biết javascript, không phù hợp cho bạn nào đã quá rành"},{"id":"67335fb1f2a382145c69b99fe4e01d34","path":"/2020-03-08-huong-dan-su-dung-react-context-nhu-the-nao-cho-hieu-qua/","title":"Sử dụng React Context như thế nào cho hiệu quả","desc":"Để có thể quản lý được state của ứng dụng một cách tốt nhất, chúng ta cần sự phân chia phù hợp giữa local state (internal state của component) và state cửa ứng dụng đặt trong React Context. Một vài điều muốn chia sẽ để nâng cao khả năng bảo trì và trải nghiệm nếu sử dụng đến context trong React."}]}},"context":{}}