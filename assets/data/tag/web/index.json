{"hash":"4f968092cc5fc7a4ca559e86be209f1fcc1d448f","data":{"tag":{"title":"web","belongsTo":{"edges":[{"node":{"id":"276dac0cac0bf3c19d5a53f3cd08f1e4","title":"Ghi chú về 3 module bundler rollup, parcel, webpack","path":"/ghi-chu-ve-3-module-bundler-rollup-parcel-webpack/","date":"2020-12-08","timeToRead":2,"desc":"","content":"<blockquote>\n<p> <strong>bundler</strong> của JS là công cụ dùng để đưa tất cả file đã <code class=\"language-text\">import</code> vào thành 1 file duy nhất. Nó còn có thể *minify` kết quả cuối cùng nếu bạn muốn.</p>\n</blockquote>\n<p>JS bundler có 3 <em>ông lớn</em> ở thời điểm hiện tại</p>\n<ul>\n<li>Parcel</li>\n<li>Rollup</li>\n<li>Webpack</li>\n</ul>\n<h3 id=\"đánh-giá-trên-việc-config-có-dễ-hay-không\"><a href=\"#%C4%91%C3%A1nh-gi%C3%A1-tr%C3%AAn-vi%E1%BB%87c-config-c%C3%B3-d%E1%BB%85-hay-kh%C3%B4ng\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Đánh giá trên việc config có dễ hay không</h3>\n<p>Parcel số 1, gần như không phải làm gì</p>\n<p>Webpack và Rollup yêu cầu phải có file config riêng.</p>\n<p>Rollup có sẵn polyfill cho <code class=\"language-text\">import/export</code>, webpack chưa có</p>\n<p>Rollup hỗ trợ relative path, webpack phải dùng <code class=\"language-text\">path.resolve</code> hoặc <code class=\"language-text\">path.join</code></p>\n<p>Config webpack phức tạp nhất, được cái hỗ trợ nhiều third-party</p>\n<h3 id=\"loại-bỏ-code-không-sử-dụng\"><a href=\"#lo%E1%BA%A1i-b%E1%BB%8F-code-kh%C3%B4ng-s%E1%BB%AD-d%E1%BB%A5ng\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Loại bỏ code không sử dụng</h3>\n<p>Loại bỏ code không sử dụng, còn gọi dead code, Tree shaking rất cần thiết để nâng cao hiệu năng.</p>\n<p>Parcel vẫn là số 1. Hỗ trợ tree-shaking cả ES6 và CommonJS</p>\n<p>Rollup đứng thứ 2.</p>\n<p>Webpack thì phải thủ công config để có tree-shaking.</p>\n<p>Rollup và webpack tập trung tree-shaking với ES6.</p>\n<h3 id=\"code-splitting\"><a href=\"#code-splitting\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Code splitting</h3>\n<p>Webpack số 1, đúng kiểu làm ít hưởng nhiều. Có 3 lựa chọn</p>\n<ul>\n<li>Sử dụng config entry</li>\n<li>Sử dụng plugin CommonsChunkPlugin</li>\n<li>Dynamic import</li>\n</ul>\n<p>Rollup và Parcel hỗ trợ splitting ngay từ đầu, nhưng đang vướng nhiều issue bị report.</p>\n<p>Webpack vẫn là lựa chọn hàng đầu.</p>\n<h3 id=\"live-reload\"><a href=\"#live-reload\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Live reload</h3>\n<p>Parcel gặp một số vấn đề với HTTP logging, Hooks và middleware</p>\n<p>Rollup phải cài thêm <code class=\"language-text\">rollup-plugin-serve</code>, <code class=\"language-text\">rollup-plugin-livereload</code> chứ không có sẵn.</p>\n<p>Webpack cài thêm <code class=\"language-text\">webpack-dev-server</code>.</p>\n<p>Khả năng tùy chỉnh của webpack sẽ cao hơn Rollup và Parcel.</p>\n<h3 id=\"module-transform\"><a href=\"#module-transform\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Module transform</h3>\n<p>Các bundler chỉ hỗ trợ file JS, với các file khác chúng ta cần thêm plugin</p>\n<p><img src=\"https://miro.medium.com/max/300/1*fQYPJhmQuHA93GWcChKBTw.png\"></p>\n<p>Parcel hỗ trợ sẵn tất cả những kiểu file quen thuộc, không cần đụng đến config. Không những vậy, khi gặp các file config <code class=\"language-text\">.babelrc</code>, <code class=\"language-text\">.postcssrc</code>, <code class=\"language-text\">.posthtml</code> nó sẽ tự handle</p>\n<p>Webpack và Rollup cần thêm plugin và config mới có transform và transpiler.</p>\n<h2 id=\"kết\"><a href=\"#k%E1%BA%BFt\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kết</h2>\n<ul>\n<li>Nhanh gọn lẹ, app đơn giản, chọn Parcel</li>\n<li>Làm thư viện, hạn chế third-party, dùng Rollup</li>\n<li>App phức tạp, nhiều third-party, dùng webpack.</li>\n</ul>\n<p>Ghi chú từ <a href=\"https://medium.com/better-programming/the-battle-of-bundlers-6333a4e3eda9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rollup vs. Parcel vs. webpack: Which Is the Best Bundler?</a></p>\n","cover_image":""}},{"node":{"id":"307e7c23d055c29830eecf1a597f82d9","title":"Ghi chú về JWT","path":"/ghi-chu-ve-jwt/","date":"2020-12-05","timeToRead":3,"desc":"JWT đã không còn mới lạ ở năm 2020, tóm tắt một những vấn đề chính cần quan tâm khi làm việc với JWT","content":"<!-- TOC -->\n<ul>\n<li><a href=\"#c%C6%A1-b%E1%BA%A3n-c%E1%BA%A7n-n%E1%BA%AFm\">Cơ bản, cần nắm</a></li>\n<li><a href=\"#ph%C3%ADa-backend\">Phía Backend</a></li>\n<li>\n<p><a href=\"#ph%C3%ADa-client-d%C3%B9ng-spa\">Phía client dùng SPA</a></p>\n<ul>\n<li><a href=\"#so-s%C3%A1nh-%C4%91%E1%BB%8Bnh-danh-b%E1%BA%B1ng-session-v%C3%A0-token\">So sánh định danh bằng Session và Token</a></li>\n<li><a href=\"#v%E1%BA%A5n-%C4%91%E1%BB%81-v%E1%BB%9Bi-xss-v%C3%A0-csrf-khi-d%C3%B9ng-jwt\">Vấn đề với XSS và CSRF khi dùng JWT</a></li>\n<li><a href=\"#c%C3%B3-c%E1%BA%A7n-https-v%E1%BB%9Bi-jwt\">Có cần HTTPS với JWT?</a></li>\n<li><a href=\"#khi-n%C3%A0o-kh%C3%B4ng-n%C3%AAn-d%C3%B9ng-jwt\">Khi nào không nên dùng JWT</a></li>\n<li><a href=\"#th%C6%B0-vi%E1%BB%87n-ngon\">Thư viện ngon</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h2 id=\"cơ-bản-cần-nắm\"><a href=\"#c%C6%A1-b%E1%BA%A3n-c%E1%BA%A7n-n%E1%BA%AFm\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cơ bản, cần nắm</h2>\n<p>JWT có thể nhớ nôm na là một JSON đã <strong>encrypt</strong> => gọi là <em>token</em>, chứa thông tin giúp backend có thể định danh bạn là ai, bạn có quyền gì</p>\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--Lmyom2tH--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://paper-attachments.dropbox.com/s_1048F41B3AC814B927887FF3C86602B940107555916A37D85A0BACB9135A34EA_1606545347515_jwt.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--Lmyom2tH--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://paper-attachments.dropbox.com/s_1048F41B3AC814B927887FF3C86602B940107555916A37D85A0BACB9135A34EA_1606545347515_jwt.png\" alt=\"img\"></a></p>\n<p>Nguyên nhân ra đời của JWT là để giải quyết bài toán <strong>định danh</strong> trong <em>microservice</em></p>\n<h2 id=\"phía-backend\"><a href=\"#ph%C3%ADa-backend\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Phía Backend</h2>\n<p>Ở phía Backend có 2 vấn đề chính cần quan tâm</p>\n<ol>\n<li>Tạo như thế nào</li>\n<li>Validate ra làm sao</li>\n</ol>\n<p>Việc tạo, sử dụng những thư viện có sẵn (<a href=\"https://www.npmjs.com/package/jsonwebtoken\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">jsonwebtoken</a> nếu bạn đang dùng Node.js), Ưchỉ cần quan tâm những giá trị <em>đã</em>  hoặc <em>muốn</em> nhét thêm trong JSON</p>\n<p>Một trường tối quan trong trong JSON là <code class=\"language-text\">expiresIn</code>, cho phép token sẽ expire sau bao lâu.</p>\n<p>Việc validate, thì dùng thư viện nào tạo token, nó sẽ có luôn phương thức để kiểm tra token đó có hợp lệ không.</p>\n<h2 id=\"phía-client-dùng-spa\"><a href=\"#ph%C3%ADa-client-d%C3%B9ng-spa\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Phía client dùng SPA</h2>\n<h3 id=\"so-sánh-định-danh-bằng-session-và-token\"><a href=\"#so-s%C3%A1nh-%C4%91%E1%BB%8Bnh-danh-b%E1%BA%B1ng-session-v%C3%A0-token\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>So sánh định danh bằng Session và Token</h3>\n<p>Giống nhau</p>\n<ol>\n<li>Chức năng như nhau, để định danh</li>\n<li>Sau khi định danh ở Backend, nó trả về token cho client</li>\n<li>Gửi kèm token trên khi muốn dùng một service ở phía backend</li>\n</ol>\n<p>Khác nhau</p>\n<ul>\n<li>Session thì dữ liệu và trạng thái đăng nhập của user được lưu ở bộ nhớ phía server. Không phù hợp với RESTful APIs, mỗi service đều phải <code class=\"language-text\">stateless</code>, anh là ai, anh từ đâu tới đều phải đưa chứng minh nhân dân chứ chúng tôi không ai rảnh đầu ngồi nhớ mặt hết những ai ra vào service.</li>\n<li>Session sẽ lưu thông tin về user ở <strong>cookie</strong> của trình duyệt, vấn đề là các service có thể khác domain, trình duyệt không biết và sẽ không đưa thông tin cookie cho các domain khác</li>\n</ul>\n<h3 id=\"vấn-đề-với-xss-và-csrf-khi-dùng-jwt\"><a href=\"#v%E1%BA%A5n-%C4%91%E1%BB%81-v%E1%BB%9Bi-xss-v%C3%A0-csrf-khi-d%C3%B9ng-jwt\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Vấn đề với XSS và CSRF khi dùng JWT</h3>\n<p>Hết sức thận trọng khi xử lý JWT trong code, token là mồi ngon cho XSS và CSRF</p>\n<p>Tuyệt đối không dùng local storage để lưu JWT trên phía frontend. Localstorage có thể được truy xuất bằng JS cùng domain, attacker có thể dùng điểm này để inject thêm mã để lấy local storage. (XSS)</p>\n<p>Vì cookie được gửi trên tất cả <em>request</em>, attacker có thể lợi dụng điểm này để gửi một link yêu cầu đổi password (CSRF)</p>\n<p>Nếu không còn lựa chọn nào khác, lưu trong bộ nhớ, lưu ý sẽ mất khi user refresh.</p>\n<p>Cookie thật ra không phải là không dùng được, nhưng dùng thì phải kiểm tra</p>\n<ul>\n<li>Dùng <code class=\"language-text\">httpOnly</code> để cookie không thể được truy cập thông qua JS</li>\n<li>Dùng <code class=\"language-text\">SameSite</code> để hạn chế  cấp phát cookie đi các domain chỉ định. Nếu phải đưa qua nhiều domain khác nhau, dùng <em>Lax</em>, nó cho phép gọi truyền cookie khác domain nếu là <code class=\"language-text\">GET</code></li>\n</ul>\n<p>Nếu muốn 100% an toàn tuyệt đối, phải trả một cái giá không rẻ, như tắt cross-domain request.</p>\n<p>Nếu sử dụng <code class=\"language-text\">axios</code>, và backend tạo cookie đúng chuẩn, để axios lo phần đó cho an toàn, không cần lo việc xử lý token, cookie một cách thủ công, thiếu chuyên nghiệp.</p>\n<pre class=\"language-js\"><code class=\"language-js\">axios<span class=\"token punctuation\">.</span><span class=\"token property-access\">defaults</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">withCredentials</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></code></pre>\n<p><a href=\"https://github.com/deleteman/sample-jwt-auth-vue\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Code tham khảo</a></p>\n<h3 id=\"có-cần-https-với-jwt\"><a href=\"#c%C3%B3-c%E1%BA%A7n-https-v%E1%BB%9Bi-jwt\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Có cần HTTPS với JWT?</h3>\n<p>HTTPS có đảm bảo an toàn tuyệt đối cho site, là yêu cầu bắt buộc khi sử dụng JWT?</p>\n<p>100% bảo mật là con số chưa ai dám nhận, hay nói toẹt ra là không thể. Sẽ luôn có đâu đó một con người tài giỏi, thông minh hơn bạn, họ sẽ tìm được cách tấn công phù hợp. May mắn thay những người xuất chúng như vậy họ cũng có đạo đức cao và không rảnh để làm những việc quá tầm thường. Đừng có lên mạng mà \"Anh đố chú hack được site anh!\"</p>\n<p>HTTPS là cơ chế <strong>encrypt</strong> thông tin đi-về giữa client và server, đảm bảo không có người ngoài nào có thể dòm ngó và đọc được bạn đang gửi gì, nhưng nếu nó đã chui được vào nhà bạn rồi thì thành thật mà nói HTTPS cũng không phải là cánh cửa chỉ có bạn mở được.</p>\n<h3 id=\"khi-nào-không-nên-dùng-jwt\"><a href=\"#khi-n%C3%A0o-kh%C3%B4ng-n%C3%AAn-d%C3%B9ng-jwt\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Khi nào không nên dùng JWT</h3>\n<p>Nếu bạn đang muốn sử dụng một stateful backend, JWT là thừa thãi không cần thiết.</p>\n<p>JWT sinh ra và phù hợp nhất với stateless API</p>\n<h3 id=\"thư-viện-ngon\"><a href=\"#th%C6%B0-vi%E1%BB%87n-ngon\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Thư viện ngon</h3>\n<p>Vue: <a href=\"https://www.npmjs.com/package/vuejs-jwt\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">vuejs-jwt</a></p>\n<p>React: <a href=\"https://www.npmjs.com/package/react-jwt\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react-jwt</a></p>\n<p>Angular: <a href=\"https://www.npmjs.com/package/@auth0/angular-jwt\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">angular-jwt</a></p>\n<p>Ghi chú từ bài viết <a href=\"https://dev.to/deleteman123/jwt-authentication-best-practices-3lf9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JWT Authentication Best Practices</a></p>\n","cover_image":""}},{"node":{"id":"756b1766138731f4a766ba12486ddb4c","title":"Tóm tắt quá trình render của trình duyệt","path":"/tom-tat-qua-trinh-render-cua-trinh-duyet/","date":"2020-12-03","timeToRead":2,"desc":"Tóm lược các bước chính trình duyệt cần thực hiện để render một trang web","content":"<!-- TOC -->\n<ul>\n<li><a href=\"#parse-html\">Parse HTML</a></li>\n<li><a href=\"#2---external-resource\">2 - External Resource</a></li>\n<li><a href=\"#3---parse-css\">3 - Parse CSS</a></li>\n<li><a href=\"#4---execute-js\">4 - Execute JS</a></li>\n<li><a href=\"#5---merge-dom-v%C3%A0-cssom-%C4%91%E1%BB%83-t%E1%BA%A1o-render-tree\">5 - Merge DOM và CSSOM để tạo render tree</a></li>\n<li><a href=\"#6---calculate-layout-v%C3%A0-paint\">6 - Calculate layout và paint</a></li>\n</ul>\n<!-- /TOC -->\n<h2 id=\"parse-html\"><a href=\"#parse-html\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Parse HTML</h2>\n<p>Khi trình duyệt nhận một dữ liệu HTML, nó sẽ <strong>parse</strong> qua DOM node</p>\n<p><img src=\"https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-1.png\"></p>\n<h2 id=\"2---external-resource\"><a href=\"#2---external-resource\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2 - External Resource</h2>\n<p>Khi gặp các file CSS, JS nó sẽ chạy đi lấy dữ liệu đó, quá trình <strong>parse</strong> vẫn tiếp tục, nhưng sẽ <strong>chặn</strong> việc render trên trình duyệt (CSS được sếp vào loại resource <strong>block render</strong>)</p>\n<p>JS hơi khác, mặc định nó sẽ <strong>chặn</strong> quá trình parse HTML (<strong>block parse</strong>). Tuy nhiên với việc truyền thêm attribute <code class=\"language-text\">defer</code> hoặc <code class=\"language-text\">async</code>, việc parse js sẽ chạy ngầm, và không chặn parse HTML</p>\n<p>Với <code class=\"language-text\">defer</code>, file sẽ được execute sau khi parse document xong, nếu nhiều file được thêm thuộc tính <code class=\"language-text\">defer</code>, nó sẽ được execute theo thứ tự trong HTML</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>script.js<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">defer</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>Với <code class=\"language-text\">async</code>, file sẽ execute ngay khi load, nghĩa là có thể trong lúc parse hoặc sau lúc parse, vì vậy thứ tự đặt file không quan trọng, không đảm bảo file execute theo đúng thứ tự.</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>script.js<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">async</span><span class=\"token punctuation\">></span></span></code></pre>\n<p><a href=\"https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-2.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--5qrUxpJD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-2-1000.png\" alt=\"Fetching CSS and JavaScript resources in a web browser\"></a></p>\n<p>Với các trình duyệt sau này, nó sẽ hỗ trợ thêm việc <strong>preload</strong>, lấy về những resource chưa thật sự cần ở thời điểm hiện tại, nhưng trong tương lai có thể cần đến, việc này cũng tùy thuộc vào từng trình duyệt mà cách xử lý có khác nhau</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>style.css<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>preload<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">as</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>style<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre>\n<h2 id=\"3---parse-css\"><a href=\"#3---parse-css\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3 - Parse CSS</h2>\n<p>Sau khi đã có được source file css \"trong tay\", trình duyệt làm tiếp 2 thao tác, parse CSS và build CSSOM</p>\n<p><a href=\"https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-3.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--lDR98Pu7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-3-1000.png\" alt=\"Parsing CSS and building the CSSOM in a web browser\"></a></p>\n<h2 id=\"4---execute-js\"><a href=\"#4---execute-js\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4 - Execute JS</h2>\n<p>Các trình duyệt khác nhau, quá trình parse-compile-execute sẽ khác nhau, cũng cần nhớ thêm việc parse JS rất tốn kém tài nguyên của máy.</p>\n<p>Ngay sau khi <strong>JS đã load xong</strong> và <strong>DOM đã parse xong</strong>, sự kiện <code class=\"language-text\">document.DOMContentLoaded</code> sẽ được <em>emit</em></p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'DOMContentLoaded'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">event</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Sau khi các async JS, image load xong, sự kiện <code class=\"language-text\">window.load</code> sẽ được emit</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token dom variable\">window</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'load'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><a href=\"https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-4.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--fu8vnHfk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-4-1000.png\" alt=\"Timeline of executing JavaScript in a web browser\"></a></p>\n<h2 id=\"5---merge-dom-và-cssom-để-tạo-render-tree\"><a href=\"#5---merge-dom-v%C3%A0-cssom-%C4%91%E1%BB%83-t%E1%BA%A1o-render-tree\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>5 - Merge DOM và CSSOM để tạo render tree</h2>\n<p>Hợp thể giữa DOM và CSSOM sẽ cho ra <strong>render tree</strong>, là toàn bộ những gì sẽ hiển thị trên trình duyệt</p>\n<p><a href=\"https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-5.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--ay06Rl9_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-5-1000.png\" alt=\"Merging the DOM and CSSOM to create a render tree in a web browser\"></a></p>\n<h2 id=\"6---calculate-layout-và-paint\"><a href=\"#6---calculate-layout-v%C3%A0-paint\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>6 - Calculate layout và paint</h2>\n<p>Sau khi đã nhận được <strong>render tree</strong>, trình duyệt đã có đủ thông tin để tính toán những phần tử nào, đặt ở đâu, kích thước ra làm sao, qua trình đó gọi là calculate layout, kết thúc quá trình tính toán này, trình duyệt sẽ bắt đầu quá trình <strong>paint</strong>, là những gì user sẽ thấy trên trình duyệt, đây cũng là bước cuối cùng.</p>\n<p><a href=\"https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-6.png\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--MBpASwvG--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-6-1000.png\" alt=\"Calculating the layout and paint of a web page in a browser\"></a></p>\n<p><a href=\"https://dev.to/jstarmx/how-the-browser-renders-a-web-page-1ahc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"></a></p>\n","cover_image":""}},{"node":{"id":"ccc8cf7ca901126709bd7eb710b343dd","title":"Hướng dẫn setup tên miền GoDaddy với Github Page","path":"/huong-dan-setup-ten-mien-go-daddy-voi-github-page/","date":"2018-07-01","timeToRead":1,"desc":"Hướng dẫn cầu hình tên miền trên GoDaddy để sử dụng với Github page","content":"<p>Đăng nhập vào Goddady, mở tab My Products, chọn nút <strong>Manage</strong></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*Y9e7HtJvVv7jshINs46mTA.png\"></p>\n<p>Cuộn xuống ở dưới cuối trang, click link <strong>Manage DNS</strong></p>\n<ul>\n<li>Hàng type <strong>A</strong>, nhập vào IP của Github Server: 185.199.108.153, lên đây xem <a href=\"https://help.github.com/articles/setting-up-an-apex-domain/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://help.github.com/articles/setting-up-an-apex-domain/</a></li>\n<li>Hàng CNAME với Name \"www\" nhập địa chỉ url trang github page muốn trỏ tới, ví dụ như luubinhan.github.io/blog/</li>\n</ul>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*vL7RX_AyXRsSfO27NYF5iA.png\"></p>\n<p>Bên trong thư mục public của site, tạo thêm file tên CNAME, mở file này lên, nhập nội dung là tên miền</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*zJsdMXE8aiHEuu6ObDu7ow.png\"></p>\n<p>Xong, dễ cực. Cảm ơn bạn đã đọc hết bài viết</p>\n","cover_image":""}},{"node":{"id":"87813f0c456fbf9b04bf0d5633a9cc25","title":"Thiết kế tuyệt đẹp vs. Thực tế: bài học từ Facebook","path":"/thiet-ke-tuyet-dep-vs-thuc-te-bai-hoc-tu-facebook/","date":"2017-10-03","timeToRead":7,"desc":"Bài viết dịch lại của một anh làm product design cho facebook đăng tải trên medium","content":"<!-- TOC -->\n<ul>\n<li><a href=\"#thi%E1%BA%BFt-k%E1%BA%BF-t%E1%BB%91t-h%C6%A1n-ph%E1%BA%A3i-gi%E1%BA%A3i-quy%E1%BA%BFt-m%E1%BB%99t-v%E1%BA%A5n-%C4%91%E1%BB%81-th%E1%BB%B1c-t%E1%BA%BF-c%E1%BB%A7a-ng%C6%B0%E1%BB%9Di-s%E1%BB%AD-d%E1%BB%A5ng\">Thiết kế tốt hơn phải giải quyết một vấn đề thực tế của người sử dụng</a></li>\n<li><a href=\"#product-manager-v%C3%A0-l%E1%BA%ADp-tr%C3%ACnh-vi%C3%AAn-lu%C3%B4n-l%C3%A0-b%E1%BA%A1n-t%E1%BB%91t-nh%E1%BA%A5t\">Product Manager và Lập trình viên luôn là bạn tốt nhất</a></li>\n<li><a href=\"#b%E1%BA%A1n-%C4%91ang-thi%E1%BA%BFt-k%E1%BA%BF-s%E1%BA%A3n-ph%E1%BA%A9m-cho-ng%C6%B0%E1%BB%9Di-s%E1%BB%AD-d%E1%BB%A5ng-ho%C3%A0n-to%C3%A0n-kh%C3%A1c-b%E1%BA%A1n\">Bạn đang thiết kế sản phẩm cho người sử dụng hoàn toàn khác bạn</a></li>\n<li><a href=\"#thi%E1%BA%BFt-k%E1%BA%BF-s%E1%BA%BD-%C4%91%C6%B0%E1%BB%A3c-c%C3%A2n-%C4%91o-%C4%91ong-%C4%91%E1%BA%BFm\">Thiết kế sẽ được cân đo đong đếm</a></li>\n<li><a href=\"#c%C3%B4ng-vi%E1%BB%87c-n%C3%A0y-kh%C3%B4ng-nh%C6%B0-b%E1%BA%A1n-%C4%91%C3%A3-ngh%C4%A9\">Công việc này không như bạn đã nghĩ</a></li>\n</ul>\n<!-- /TOC -->\n<p>Khi chưa vào làm cho Facebook, tôi chưa hề biết thế nào gọi là thiết kế để giải quyết vấn đề cho người sử dụng.</p>\n<p>Tôi học được rằng giải quyết vấn đề cho người sử dụng không bao giờ là công việc đo từng ly từng tí pixel được thiết kế, nó đòi hỏi phải làm việc như một phần của team để tìm ra cách giải quyết.</p>\n<p>Ngày xửa ngày xưa tôi rất thích các trang web với nhiều hiệu ứng lạ mắt, những logo ý nghĩa, những bản thiết kế làm lại (re-design) của những designer từ khắp nơi cho những trang web nổi tiếng,... . Ngày xưa tôi từng mơ ước trở thành kế toán, tôi thích trở thành người giữ tiền cho các công ty lớn, thế rồi tôi thấy những thiết kế lộng lẫy đó trên mạng, tôi nghĩ rằng, chắc đây có thể là một công việc với nhiều điều thú vị hơn một kế toán viên.</p>\n<p>Giờ khi tôi đã là product design cho các sản phẩm của Facebook, với hơn 2 tỷ người người sử dụng, tôi biết rằng những gì tôi từng tưởng tượng trước đây về thiết kế chỉ là phần nổi của tảng băng chìm.</p>\n<h1 id=\"thiết-kế-tốt-hơn-phải-giải-quyết-một-vấn-đề-thực-tế-của-người-sử-dụng\"><a href=\"#thi%E1%BA%BFt-k%E1%BA%BF-t%E1%BB%91t-h%C6%A1n-ph%E1%BA%A3i-gi%E1%BA%A3i-quy%E1%BA%BFt-m%E1%BB%99t-v%E1%BA%A5n-%C4%91%E1%BB%81-th%E1%BB%B1c-t%E1%BA%BF-c%E1%BB%A7a-ng%C6%B0%E1%BB%9Di-s%E1%BB%AD-d%E1%BB%A5ng\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Thiết kế tốt hơn phải giải quyết một vấn đề thực tế của người sử dụng</h1>\n<p>Khi mới bắt đầu, tôi dành thời gian hàng đêm để làm những website, ứng dụng nhỏ, những dự án chẳng ai biết tới, những ý tưởng rất ngô nghê như ứng dụng hẹn hò dựa trên kết quả tìm kiếm.</p>\n<p>Lúc đó tôi đã nghĩ rằng mình là product design thực thụ. Tôi vẽ ra tất cả các màn hình, flows cho ứng dụng, và tự nhủ rằng đã xong hết 90% của công việc, phần còn lại là quăng hết đống design đó cho các anh lập trình viên code đúng theo thiết kế này và hiển nhiên ngồi bắt bẻ các anh lập trình không làm đúng ý tôi.</p>\n<p>Giờ nhìn lại, những gì trước đây mình làm còn rất xa so với công việc của product design, trước khi làm việc cho Facebook, tôi chưa bao giờ bỏ thời gian ra để xác định vấn đề cần giải quyết ở đây là gì trước khi bắt tay vào làm, tôi chỉ muốn làm cái gì đó thật \"ngầu\" để trưng lên Dribbble hay Behance để câu like.</p>\n<p>Giờ tôi không còn lơ lửng trên 9 tầng mây, tôi phải đứng cùng vị trí với người sử dụng, tôi cùng các đồng nghiệp của mình cùng nhau xác định bài toán đặt ra là gì, đưa ra một giải pháp được cho là khả thi nhất dựa trên dữ liệu chúng tôi có được, test thử giải pháp trên một số lượng nhỏ người sử dụng trước khi đưa nó vào vận hành chính thức.</p>\n<p>Giờ tôi cũng rất dễ bị hấp dẫn bởi các xu hướng thiết kế mới, nhưng không bao giờ áp những xu thế này để giải quyết các vấn đề mà không cần suy nghĩ, nó là một hành động ảnh hưởng xấu đến những người trong team đã và đang đối mặt với vấn đề đó hằng ngày, họ biết rõ vấn đề cần giải quyết là gì hơn ai hết, nó giống như câu nói \"nếu ai cũng có cây búa trong tay, thì mọi thứ chỉ như cái cán búa\".</p>\n<h1 id=\"product-manager-và-lập-trình-viên-luôn-là-bạn-tốt-nhất\"><a href=\"#product-manager-v%C3%A0-l%E1%BA%ADp-tr%C3%ACnh-vi%C3%AAn-lu%C3%B4n-l%C3%A0-b%E1%BA%A1n-t%E1%BB%91t-nh%E1%BA%A5t\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Product Manager và Lập trình viên luôn là bạn tốt nhất</h1>\n<p>Tôi từng tưởng tượng, tôi sẽ trang bị cho những designer là cấp dưới, đồng nghiệp của tôi những vũ khí 'hạng nặng' để đối phó với bên kia chiến tuyến là các anh lập trình viên cù lần. Chúng tôi sẽ cùng nhau thương thảo những vấn đề cực quan trọng như nên sử dụng màu gradient nào đang là hot trend bây giờ, hay tạo ra cái mới, bo tròn bao nhiêu là đủ, bao nhiêu là quá lố...</p>\n<p>Ở Facebook, rất nhiều cơ hội để làm việc với các designer khác. Tôi ngồi ngay kế vài anh lão làng như thế trong công ty, thế nhưng mấy anh này lại làm việc trên các sản phẩm khác, nên tôi chỉ tiếp xúc nhiều với product manager và các lập trình viên.</p>\n<p>Một designer chỉ tập trung cho một sản phẩm nào đó của Facebook, vì với độ lớn của sản phẩm mà chúng tôi đang làm, nếu các anh designer cứ nhảy từ team này qua team khác, sẽ mất khá nhiều thời gian để người mới có thể bắt kịp tốc độ dự án.</p>\n<p>Product manager là người nắm rõ nhất những gì các team đang làm. Vì thế tôi luôn tin tưởng tìm đến anh ấy khi cần một cái nhìn khác về thiết kế của mình hay những gì tôi nên tập trung nhiều hơn trên sản phẩm cần đạt được.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*LYvWth8qUnXztOkj7GUC5g@2x.jpeg\" alt=\"https://cdn-images-1.medium.com/max/800/1*LYvWth8qUnXztOkj7GUC5g@2x.jpeg\"></p>\n<p>Làm việc với mấy anh cù lần 'developer' giúp tôi trở nên tốt hơn rất nhiều, mấy anh chỉ cho tôi rất nhiều điều mà tôi không lường trước. Ví dụ, tôi thường không quan tâm đến thời gian phản hồi từ điện thoại đến server, các phác thảo của tôi gần như chỉ tính đến chuyện click-response ngay lập tức. Các anh dev cho tôi thấy việc truyền gửi dữ liệu cần tốn một thời gian nhất định và còn phụ thuộc yếu tố mạng nhanh hay chậm, anh cho tôi thấy sự khác biệt trải nghiệm rõ rệt khi mở ứng dụng của tôi với mạng siêu nhanh của công ty và mạng rùa bò ở các nước có đường truyền thấp.</p>\n<p>Sản phẩm khi thiết kế luôn chịu ảnh hưởng của yếu tố technical, ở Facebook chúng tôi luôn đưa anh lập trình vào trong quá trình thiết kế ngay từ giai đoạn đầu của design, làm như vậy để biết được những ràng buộc nhất định về mặt kỹ thuật, lắng nghe cách giải quyết vấn đề từ góc nhìn từ developer.</p>\n<p>Tôi có thể ngồi kế rất nhiều designer khác, nhưng người bạn thân thiết giúp sản phẩm của tôi tốt hơn là các anh developer và product manager</p>\n<h1 id=\"bạn-đang-thiết-kế-sản-phẩm-cho-người-sử-dụng-hoàn-toàn-khác-bạn\"><a href=\"#b%E1%BA%A1n-%C4%91ang-thi%E1%BA%BFt-k%E1%BA%BF-s%E1%BA%A3n-ph%E1%BA%A9m-cho-ng%C6%B0%E1%BB%9Di-s%E1%BB%AD-d%E1%BB%A5ng-ho%C3%A0n-to%C3%A0n-kh%C3%A1c-b%E1%BA%A1n\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Bạn đang thiết kế sản phẩm cho người sử dụng hoàn toàn khác bạn</h1>\n<p>Trừ trường hợp bạn tự làm tự xài, đa phần các sản phẩm được thiết kế ra được dành cho những người không am hiểu thiết kế, phần lớn người sử dụng sản phẩm Facebook nằm ngoài nước Mỹ, không sử dụng con Iphone đẳng cấp nhất thời đại mà tôi đang sử dụng.</p>\n<p>Team UX research ở Facebook luôn biết sản phẩm chúng tôi đang tạo ra cho ai sử dụng, họ mời những con người thật với nhiều tiêu chí khác nhau đến phòng labs để kiểm thử chức năng mới, nói chuyện với những người sử dụng từ nửa vòng trái đất, đo lường ảnh hưởng của những thay đổi trong sản phẩm bằng những đánh giá được gửi đi khắp nơi.</p>\n<p>Với những \"chứng cứ\" người thật việc thật, những người gặp rắc rối khi thực hiện một tác vụ được thiết kế, chúng tôi có được những giải pháp nhanh nhất từ những lập trình viên ưu tú.</p>\n<p>Ví dụ, thông qua research chúng tôi mới thấy được cái nút nhỏ xíu \"Add Friend\" có thể tốt trên tiếng anh nhưng với những ngôn ngữ khác lại không ổn.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*Ir4lwTDLoV0LZVobw94AAQ.png\"></p>\n<h1 id=\"thiết-kế-sẽ-được-cân-đo-đong-đếm\"><a href=\"#thi%E1%BA%BFt-k%E1%BA%BF-s%E1%BA%BD-%C4%91%C6%B0%E1%BB%A3c-c%C3%A2n-%C4%91o-%C4%91ong-%C4%91%E1%BA%BFm\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Thiết kế sẽ được cân đo đong đếm</h1>\n<p>Khi ngồi nhà thiết kế cho chính mình, tôi chẳng bao giờ nghĩ tới chuyện đi cân đo các thiết kế của mình, phần lớn khi ra quyết định một thiết kế được đưa ra dựa trên sở thích cá nhân nhiều hơn trên những số liệu, căn cứ thực tế.</p>\n<p>Ở Facebook tôi học được rằng trước khi muốn giải quyết vấn đề nào đó chúng tôi cần dựa trên những thông tin liên quan về vấn đề đó. Ai sử dụng tính năng này? Bao nhiêu người sẽ chịu ảnh hưởng từ các thay đổi được đưa ra? Những thay đổi tích cực có đủ lớn để chấp nhận rủi ro cho những thay đổi này không?</p>\n<p>Dữ liệu luôn là kẻ chiến thắng trong mọi cuộc tranh cãi. Đó là câu khẩu hiệu ở Facebook, nếu bạn là designer làm việc ở đây, nếu muốn tranh cãi vấn đề vì đó tốt hơn hãy có dữ liệu cụ thể để thuyết phục đồng đội.</p>\n<p>Khi team tôi bắt đầu đi lòng vòng quanh một vấn đề mà chưa ngã ngũ, tôi thường sử dụng câu hỏi \"Tại sao\". Tại sao chẳng ai vào mục Giúp đỡ trên website của bạn? Phải chăng họ quá rành không cần vào xem hay họ chẳng biết vào đó bằng cách nào?</p>\n<h1 id=\"công-việc-này-không-như-bạn-đã-nghĩ\"><a href=\"#c%C3%B4ng-vi%E1%BB%87c-n%C3%A0y-kh%C3%B4ng-nh%C6%B0-b%E1%BA%A1n-%C4%91%C3%A3-ngh%C4%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Công việc này không như bạn đã nghĩ</h1>\n<p>Tôi đã từng nghĩ công việc của một product design phần lớn là để làm cho sản phẩm được đẹp một cách \"lồng lộn\". Từ ngày bị lôi vào Facebook tôi nhận ra mình đã hiểu sai khái niệm về product design.</p>\n<p>Visual designer mới làm công việc trang điểm cho sản phẩm, công việc của tôi là phối hợp với đồng nghiệp của mình, xác định bài toán mà người sử dụng sản phẩm chúng tôi muốn giải quyết, chuyển nó thành những giải pháp thiết kế tốt nhất có thể, tìm ra cách đánh giá để biết chúng tôi có thành công trong việc giải quyết vấn đề đó không.</p>\n<p>Bài viết của: Jason Cashdollar | Product designer at Facebook</p>\n","cover_image":""}}]}}},"context":{}}