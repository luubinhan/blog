{"hash":"bd8bcf9d282230d74addc27b33bcc5555a134956","data":{"post":{"title":"Sử dụng React Hook Effect","path":"/su-dung-react-hook-effect/","date":"2019-07-03","timeToRead":16,"tags":[{"id":"react","title":"react","path":"/tag/react/"},{"id":"hoc-thuat","title":"hoc-thuat","path":"/tag/hoc-thuat/"}],"desc":"Bài này mình contribute cho http://vi.reactjs.org về cách sử dụng React Hook Effect","content":"<!-- TOC -->\n<ul>\n<li>\n<p><a href=\"#Effect-kh%C3%B4ng-c%E1%BA%A7n-Cleanup-effects-without-cleanup\">Effect không cần Cleanup {#effects-without-cleanup}</a></p>\n<ul>\n<li><a href=\"#V%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-Classes-example-using-classes\">Ví dụ sử dụng Classes {#example-using-classes}</a></li>\n<li><a href=\"#V%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-Hook-example-using-hooks\">Ví dụ sử dụng Hook {#example-using-hooks}</a></li>\n<li><a href=\"#Gi%E1%BA%A3i-th%C3%ADch-c%E1%BB%A5-th%E1%BB%83-detailed-explanation\">Giải thích cụ thể {#detailed-explanation}</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#Effect-c%E1%BA%A7n-Cleanup-effects-with-cleanup\">Effect cần Cleanup {#effects-with-cleanup}</a></p>\n<ul>\n<li><a href=\"#V%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-Class-example-using-classes-1\">Ví dụ sử dụng Class {#example-using-classes-1}</a></li>\n<li><a href=\"#V%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-Hooks-example-using-hooks-1\">Ví dụ sử dụng Hooks {#example-using-hooks-1}</a></li>\n</ul>\n</li>\n<li><a href=\"#T%E1%BB%95ng-h%E1%BB%A3p-recap\">Tổng hợp {#recap}</a></li>\n<li>\n<p><a href=\"#Tip-s%E1%BB%AD-d%E1%BB%A5ng-Effect-tips-for-using-effects\">Tip sử dụng Effect {#tips-for-using-effects}</a></p>\n<ul>\n<li><a href=\"#Tip-S%E1%BB%AD-d%E1%BB%A5ng-nhi%E1%BB%81u-Effect-t%C3%A1ch-bi%E1%BB%87ttip-use-multiple-effects-to-separate-concerns\">Tip: Sử dụng nhiều Effect tách biệt{#tip-use-multiple-effects-to-separate-concerns}</a></li>\n<li><a href=\"#Gi%E1%BA%A3i-th%C3%ADch-T%E1%BA%A1i-sao-Effect-ch%E1%BA%A1y-tr%C3%AAn-m%E1%BB%97i-update-explanation-why-effects-run-on-each-update\">Giải thích: Tại sao Effect chạy trên mỗi update {#explanation-why-effects-run-on-each-update}</a></li>\n<li><a href=\"#Tip-T%E1%BB%91i-%C6%B0u-Performance-b%E1%BA%B1ng-c%C3%A1ch-b%E1%BB%8F-qua-Effect-tip-optimizing-performance-by-skipping-effects\">Tip: Tối ưu Performance bằng cách bỏ qua Effect {#tip-optimizing-performance-by-skipping-effects}</a></li>\n</ul>\n</li>\n<li><a href=\"#B%C6%B0%E1%BB%9Bc-ti%E1%BA%BFp-theo-next-steps\">Bước tiếp theo {#next-steps}</a></li>\n</ul>\n<!-- /TOC -->\n<p><em>Hook</em> là một tính năng mới từ React 16.8. Nó cho phép sử dụng state và các tính năng khác của React mà không cần viết dạng class</p>\n<p><em>Effect Hook</em> cho phép thực hiện side effect bên trong các function component:</p>\n<pre class=\"language-js{1,6-10}\"><code class=\"language-js{1,6-10}\">import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // Tương tự như componentDidMount và componentDidUpdate:\n  useEffect(() => {\n    // Cập nhập document title sử dụng browser API\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}</code></pre>\n<p>Đoạn snippet này dựa trên <a href=\"http://vi.reactjs.org/docs/hooks-state.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ví dụ về counter ở trang trước</a>, chúng ta có thêm tính năng mới: đặt giá trị document title tương ứng với số lần click.</p>\n<p>Fetching data, thiết lập các subscription, và tự ý thay đổi DOM trong React component, những hành động như vậy được là \"side effect\" (hoặc \"effect\").</p>\n<blockquote>\n<p>Tip</p>\n<p>Nếu bạn quen với các phương thức lifecycle của React class, bạn có thể hình dung <code class=\"language-text\">useEffect</code> Hook như sự kết hợp của <code class=\"language-text\">componentDidMount</code>, <code class=\"language-text\">componentDidUpdate</code>, và <code class=\"language-text\">componentWillUnmount</code>.</p>\n</blockquote>\n<p>Có 2 loại side effect phổ biến trong React component: loại không cần cleanup, và loại cần. Cùng phân biệt 2 loại này kỹ hơn.</p>\n<h2 id=\"effect-không-cần-cleanup-effects-without-cleanup\"><a href=\"#effect-kh%C3%B4ng-c%E1%BA%A7n-cleanup-effects-without-cleanup\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Effect không cần Cleanup {#effects-without-cleanup}</h2>\n<p>Đôi lúc, chúng ta muốn <strong>chạy một vài đoạn code sau khi React đã cập nhập DOM.</strong> Network request, tự ý thay đổi DOM, và logging là những ví dụ điển hình của effect không cần cleanup. Chúng ta gọi như vậy vì có thể chạy chúng và quên ngay lập tức. Hãy so sánh class và Hook cho phép thực hiện side effect như thế ra sao.</p>\n<h3 id=\"ví-dụ-sử-dụng-classes-example-using-classes\"><a href=\"#v%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-classes-example-using-classes\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ví dụ sử dụng Classes {#example-using-classes}</h3>\n<p>Trong React class components, phương thức <code class=\"language-text\">render</code> không được phép tạo ra side effect. Nó sẽ là quá sớm -- chúng ta thường chỉ muốn chạy effect <em>sau khi</em> React đã cập nhập DOM.</p>\n<p>Đó là lý do tại sao trong React class, chúng ta đặt side effect bên trong <code class=\"language-text\">componentDidMount</code> và <code class=\"language-text\">componentDidUpdate</code>. Quay lại ví dụ, đây là React counter class component sẽ cập nhập document title ngay sau khi React thay đổi DOM:</p>\n<pre class=\"language-js{9-15}\"><code class=\"language-js{9-15}\">class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}</code></pre>\n<p>Để ý cách <strong>chúng ta đã lập lại 2 thao tác tương tự nhau bên trong 2 phương thức lifecycle</strong></p>\n<p>Đó là bởi vì trong đa phần các trường hợp, chúng ta muốn thực hiện cùng một side effect khi component đã mount hoặc đã update. Một cách tổng quát, chúng ta muốn thực hiện sau mỗi lần render -- nhưng React class component không có phương thức như vậy. Chúng ta có thể tách nó ra thành một hàm riêng, nhưng vẫn phải gọi nó ở 2 nơi khác nhau.</p>\n<p>Bây giờ chúng ta xem cách làm tương tự với <code class=\"language-text\">useEffect</code> Hook.</p>\n<h3 id=\"ví-dụ-sử-dụng-hook-example-using-hooks\"><a href=\"#v%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-hook-example-using-hooks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ví dụ sử dụng Hook {#example-using-hooks}</h3>\n<p>Chúng ta đã xem ví dụ ở trên, giờ xem kỹ hơn một lần nữa:</p>\n<pre class=\"language-js{1,6-8}\"><code class=\"language-js{1,6-8}\">import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}</code></pre>\n<p><strong><code class=\"language-text\">useEffect</code> đã làm gì?</strong> Bằng cách sử dụng Hook này, chúng ta nói với React rằng component của chúng ta cần thực hiện một việc gì đó sau khi render. React sẽ ghi nhớ hàm bạn truyền vào (chúng tôi thích gọi nó là \"effect\"), và sau đó gọi lại hàm này sau khi DOM đã update. Trong effect này, chúng ta đổi document title, chúng ta cũng có thể  fetch data hoặc gọi một số API khác.</p>\n<p><strong>Tại sao <code class=\"language-text\">useEffect</code> được gọi bên trong component?</strong> Đặt <code class=\"language-text\">useEffect</code> bên trong component cho phép chúng ta truy xuất đến state <code class=\"language-text\">count</code> (hoặc bất kỳ prop nào) bên trong effect. Chúng ta không cần một API đặc biệt để đọc nó -- nó đã nằm trong scope của function. Hook tận dụng JavaScript closures và tránh cung cấp thêm các APIs mà bản thân JavaScript đã có sẵn giải pháp.</p>\n<p><strong><code class=\"language-text\">useEffect</code> chạy sau tất cả những lần render?</strong> Đúng! Theo mặc định, nó chạy sau lần render đầu tiên <em>và</em> mỗi lần update. (Chúng ta sẽ nói về <a href=\"#tip-optimizing-performance-by-skipping-effects\">làm cách nào để tùy biến lại</a>.) Thay vì nghĩ theo hướng \"mounting\" và \"updating\", bạn sẽ thấy dễ hiểu hơn nếu nghĩ theo kiểu \"sau khi render\". React đảm bảo DOM đã được update trước khi chạy effect.</p>\n<h3 id=\"giải-thích-cụ-thể-detailed-explanation\"><a href=\"#gi%E1%BA%A3i-th%C3%ADch-c%E1%BB%A5-th%E1%BB%83-detailed-explanation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Giải thích cụ thể {#detailed-explanation}</h3>\n<p>Giờ chúng ta đã hiểu về effect, đoạn code này sẽ rất dễ hiểu:</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\"><span class=\"token maybe-class-name\">Example</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">title</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">You clicked </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>count<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> times</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Chúng ta khai báo state <code class=\"language-text\">count</code>, và sau đó nói với React chúng ta cần sử dụng. Chúng ta truyền cho <code class=\"language-text\">useEffect</code> Hook một hàm. Hàm truyền vào này <em>là</em> effect. Bên trong effect, chúng ta đặt document title sử dụng API <code class=\"language-text\">document.title</code>. Chúng ta có thể đọc giá trị sau cùng của <code class=\"language-text\">count</code> bên trong effect bởi vì nó nằm chung scope với function. Khi React render component, nó sẽ nhớ lại effect chúng ta đã gửi, và chạy effect sau khi cập nhập DOM. Nó xảy ra ở tất cả các lần render, kể cả lần đầu.</p>\n<p>Lập trình viên JavaScript có kinh nghiệm sẽ để ý thấy function truyền vào cho <code class=\"language-text\">useEffect</code> sẽ khác nhau cho tất cả các lần render. Đây là điều cố ý. Thật ra, nó sẽ cho chúng ta đọc giá trị <code class=\"language-text\">count</code> bên trong effect mà không cần lo lắng về việc lấy state. Mỗi lần chúng ta re-render, chúng ta gọi một effect <strong>khác</strong>, thay thế cái trước đó. Bằng cách này, nó làm cho effect như một phần của việc render -- mỗi effect \"thuộc vào\" một render cụ thể. Chúng ta sẽ hiểu tại sao cách này lại hiệu quả <a href=\"#explanation-why-effects-run-on-each-update\">ở phần sau của bài này</a>.</p>\n<blockquote>\n<p>Tip</p>\n<p>Không giống <code class=\"language-text\">componentDidMount</code> hoặc <code class=\"language-text\">componentDidUpdate</code>, effect chạy với <code class=\"language-text\">useEffect</code> không block trình duyệt cập nhập màn hình. Các effect chủ yếu không cần xảy ra tuần tự. Trong vài tình huống không mấy phổ biến (ví dụ như đo layout), chúng ta có  <a href=\"http://vi.reactjs.org/docs/hooks-reference.html#uselayouteffect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">useLayoutEffect</code></a> Hook với API tính năng tương tự như <code class=\"language-text\">useEffect</code>.</p>\n</blockquote>\n<h2 id=\"effect-cần-cleanup-effects-with-cleanup\"><a href=\"#effect-c%E1%BA%A7n-cleanup-effects-with-cleanup\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Effect cần Cleanup {#effects-with-cleanup}</h2>\n<p>Ở trên, chúng ta đã bàn về những side effect không cần cleanup. Tuy nhiên, một vài effect cần có. Ví dụ, <strong>chúng ta muốn thiết lập các subscription</strong> cho vài data source bên ngoài. Tình huống đó, clean up là rất quan trọng để không xảy ra memory leak! Cùng so sánh cách làm giữa class và Hook</p>\n<h3 id=\"ví-dụ-sử-dụng-class-example-using-classes-1\"><a href=\"#v%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-class-example-using-classes-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ví dụ sử dụng Class {#example-using-classes-1}</h3>\n<p>Trong React class, chúng ta thường cài đặt một subscription trong <code class=\"language-text\">componentDidMount</code>, và clean it up trong <code class=\"language-text\">componentWillUnmount</code>. Lấy ví dụ, chúng ta có <code class=\"language-text\">ChatAPI</code> module cho phép chúng ta subscribe vào tình trạng online của 1 danh sách friend. Cách chúng ta làm với class</p>\n<pre class=\"language-js{8-26}\"><code class=\"language-js{8-26}\">class FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n\n  render() {\n    if (this.state.isOnline === null) {\n      return 'Loading...';\n    }\n    return this.state.isOnline ? 'Online' : 'Offline';\n  }\n}</code></pre>\n<p>Để ý <code class=\"language-text\">componentDidMount</code> và <code class=\"language-text\">componentWillUnmount</code>. Phương thức Lifecycle buộc chúng ta tách logic này ra thậm chí cả 2 đoạn code trên điều liên quan đến cùng một effect.</p>\n<blockquote>\n<p>Lưu ý</p>\n<p>Nếu để ý kỹ hơn, bạn sẽ thấy chúng ta còn cần thêm <code class=\"language-text\">componentDidUpdate</code> để thực sự chuẩn xác. Tạm thời cứ bỏ qua phần đó vì chúng ta sẽ đề cập lại <a href=\"#explanation-why-effects-run-on-each-update\">ở phần sau</a> of this page.</p>\n</blockquote>\n<h3 id=\"ví-dụ-sử-dụng-hooks-example-using-hooks-1\"><a href=\"#v%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-hooks-example-using-hooks-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ví dụ sử dụng Hooks {#example-using-hooks-1}</h3>\n<p>Cùng xem cách chúng ta làm với Hook.</p>\n<p>Bạn có thể sẽ nghĩ chúng ta cần 2 effect khác nhau để thực hiện cleanup. Code khởi tạo và xóa subscription luôn luôn đứng kề nhau, <code class=\"language-text\">useEffect</code> được thiết kế để dữ chúng cùng một chỗ. Nếu effect trả về function, React sẽ chạy  function đó, chúng ta đưa clean up vào bên trong function trả về:</p>\n<pre class=\"language-js{6-16}\"><code class=\"language-js{6-16}\">import React, { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // Chỉ định clean up sau khi gọi effect:\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}</code></pre>\n<p><strong>Tại sao chúng ta trả về function bên trong effect?</strong> Đây là một tùy chọn để chạy cơ chế cleanup cho effect. Nó cho phép chúng ta đưa tạo và xóa subscription trong cùng một effect.</p>\n<p><strong>Khi nào React clean up một effect?</strong> React thực hiện cleanup khi  component unmount. Tuy nhiên, như đã học trước đó, effect trên tất cả những lần render, không phải chỉ một. Đó là tại sao React <em>đồng thời</em> cleans up effect từ những lần render trước. Chúng ta sẽ thảo luận thêm <a href=\"#explanation-why-effects-run-on-each-update\">việc này giúp tránh bug</a> và <a href=\"#tip-optimizing-performance-by-skipping-effects\">làm cách nào tùy biến đặc tính này để cái thiện performance </a> ở bên dưới.</p>\n<blockquote>\n<p>Ghi chú</p>\n<p>Chúng ta không cần trả về một function có tên trong effect. Chúng ta gọi nó là <code class=\"language-text\">cleanup</code> để chỉ rõ mục đích, bạn có thể dùng arrow function trong thực tế.</p>\n</blockquote>\n<h2 id=\"tổng-hợp-recap\"><a href=\"#t%E1%BB%95ng-h%E1%BB%A3p-recap\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tổng hợp {#recap}</h2>\n<p>Chúng ta đã học <code class=\"language-text\">useEffect</code> cho phép chúng ta thực hiện nhiều kiểu side effect sau khi component được render. Một vài effect cần cleanup nó sẽ return một function:</p>\n<pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">handleStatusChange</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">status</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setIsOnline</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">.</span><span class=\"token property-access\">isOnline</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Một vài effect khác có thể không cần cleanup, thì không cần return gì cả.</p>\n<pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">title</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">You clicked </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>count<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> times</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Effect Hook được sử dụng trong cả 2 trường hợp.</p>\n<hr>\n<p><strong>Nếu bạn đã nắm bắt được cách làm việc của Effect Hook, hoặc nếu bạn cảm thấy hơi ngợp, có thể nhảy xuống <a href=\"http://vi.reactjs.org/docs/hooks-rules.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">phần Nguyên tắc sử dụng Hook</a> bây giờ.</strong></p>\n<hr>\n<h2 id=\"tip-sử-dụng-effect-tips-for-using-effects\"><a href=\"#tip-s%E1%BB%AD-d%E1%BB%A5ng-effect-tips-for-using-effects\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tip sử dụng Effect {#tips-for-using-effects}</h2>\n<p>Chúng ta sẽ cùng đi sâu một số khía cạnh của <code class=\"language-text\">useEffect</code> mà các lập trình viên React có kinh nghiệm sẽ thắc mắc. Không cần quá cưỡng ép bản thân, bạn có thể dừng ở đây, và quay lại để tìm hiểu Effect Hook bất cứ lúc nào.</p>\n<h3 id=\"tip-sử-dụng-nhiều-effect-tách-biệttip-use-multiple-effects-to-separate-concerns\"><a href=\"#tip-s%E1%BB%AD-d%E1%BB%A5ng-nhi%E1%BB%81u-effect-t%C3%A1ch-bi%E1%BB%87ttip-use-multiple-effects-to-separate-concerns\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tip: Sử dụng nhiều Effect tách biệt{#tip-use-multiple-effects-to-separate-concerns}</h3>\n<p>Một trong những vấn đề đã liệt kê ở  <a href=\"http://vi.reactjs.org/docs/hooks-intro.html#complex-components-become-hard-to-understand\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">động lực</a> tạo ra Hooks là các phương thức lifecycle của class thường chứa những logic không liên quan với nhau, còn những logic đáng lý phải nằm gần nhau lại nằm ở các phương thức khác nhau. Đây là component kết hợp counter và friend status từ ví dụ ở trên</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">FriendStatusWithCounter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">state</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> count<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> isOnline<span class=\"token operator\">:</span> <span class=\"token keyword null nil\">null</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">handleStatusChange</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">handleStatusChange</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">title</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">You clicked </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">state</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">count</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> times</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">props</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">handleStatusChange</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">title</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">You clicked </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">state</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">count</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> times</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">props</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">handleStatusChange</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">handleStatusChange</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">status</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      isOnline<span class=\"token operator\">:</span> status<span class=\"token punctuation\">.</span><span class=\"token property-access\">isOnline</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span></code></pre>\n<p>Để ý cái logic của <code class=\"language-text\">document.title</code> đang nằm ở <code class=\"language-text\">componentDidMount</code> và <code class=\"language-text\">componentDidUpdate</code>. Logic của subscription thì cũng nằm ở  <code class=\"language-text\">componentDidMount</code> và <code class=\"language-text\">componentWillUnmount</code>. Và <code class=\"language-text\">componentDidMount</code> chứa code cả hai.</p>\n<p>Như vậy hook đã giải quyết vấn đề này như thế nào? Nếu như <a href=\"http://vi.reactjs.org/docs/hooks-state.html#tip-using-multiple-state-variables\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">bạn có thể sử dụng <em>State</em> Hook nhiều lần</a>, bạn cũng có thể sử dụng nhiều effect. Nó cho phép tách những logic không liên quan ra thành những effect khác nhau:</p>\n<pre class=\"language-js{3,8}\"><code class=\"language-js{3,8}\">function FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n  // ...\n}</code></pre>\n<p><strong>Hook cho phép tách code dựa trên cái nó đang làm</strong> chứ không đi theo phương thức lifecycle. React sẽ apply <em>từng</em> effect được sử dụng trong component, theo thứ tự đã khai báo.</p>\n<h3 id=\"giải-thích-tại-sao-effect-chạy-trên-mỗi-update-explanation-why-effects-run-on-each-update\"><a href=\"#gi%E1%BA%A3i-th%C3%ADch-t%E1%BA%A1i-sao-effect-ch%E1%BA%A1y-tr%C3%AAn-m%E1%BB%97i-update-explanation-why-effects-run-on-each-update\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Giải thích: Tại sao Effect chạy trên mỗi update {#explanation-why-effects-run-on-each-update}</h3>\n<p>Nếu đã từng sử dụng class, bạn sẽ thắc mắc tại sao bước cleanup effect lại chạy trên mỗi lần re-render, mà không phải khi unmounting. Xét một ví dụ thực tế để thấy tại sao thiết kế này giúp chúng ta có những component ít bug hơn</p>\n<p><a href=\"#example-using-classes-1\">Ở phần trước</a>, chúng ta có đề cập ví dụ <code class=\"language-text\">FriendStatus</code> để hiển thị trạng thái online của Friend. Class đọc <code class=\"language-text\">friend.id</code> từ <code class=\"language-text\">this.props</code>, subscribe sau khi component mount, và unsubscribe trong lúc unmounting:</p>\n<pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">props</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">handleStatusChange</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">props</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">handleStatusChange</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<p><strong>Chuyện gì sẽ xảy ra nếu prop <code class=\"language-text\">friend</code> thay đổi</strong> trong khi component đang hiển thị trên màn hình (chưa unmount)? Chắc chắn có bug với danh sách status. Chúng ta cũng có thể gây ra memory leak hoặc crash khi đang unmounting và gọi unsubscribe nếu có một Friend ID không đúng.</p>\n<p>Trong class component, chúng ta cần thêm <code class=\"language-text\">componentDidUpdate</code> để xử lý tình huống này:</p>\n<pre class=\"language-js{8-19}\"><code class=\"language-js{8-19}\">  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  componentDidUpdate(prevProps) {\n    // Unsubscribe friend.id trước đó\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      this.handleStatusChange\n    );\n    // Subscribe friend.id mới\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }</code></pre>\n<p>Quên handle <code class=\"language-text\">componentDidUpdate</code> là điều dễ dẫn tới có bug trong React.</p>\n<p>Đây là phiên bản sử dụng Hook</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\"><span class=\"token maybe-class-name\">FriendStatus</span></span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span><span class=\"token property-access\">friend</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">id</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Không còn bị dính bug như ở trên</p>\n<p>Sẽ không có một đoạn code nào đặc biệt để xử lý lúc update vì theo cách chạy <em>mặc định</em> của <code class=\"language-text\">useEffect</code> nó đã xóa effect trước khi apply effect mới. Để hình dung hóa, đây là các bước gọi subscribe và unsubscribe mà component đã chạy qua:</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Mount với prop { friend: { id: 100 } }</span>\n<span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// Chạy effect đầu tiên</span>\n\n<span class=\"token comment\">// Cập nhập prop { friend: { id: 200 } }</span>\n<span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Clean effect trước đó</span>\n<span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// Chạy effect tiếp theo</span>\n\n<span class=\"token comment\">// Cập nhập với { friend: { id: 300 } }</span>\n<span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Clean effect trước đó</span>\n<span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">subscribeToFriendStatus</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// Chạy effect tiếp theo</span>\n\n<span class=\"token comment\">// Unmount</span>\n<span class=\"token maybe-class-name\">ChatAPI</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">unsubscribeFromFriendStatus</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">,</span> handleStatusChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Clean effect lần cuối</span></code></pre>\n<p>Đặc tính này đảm bảo thống nhất và ngăn bug thường xuất hiện do không cập nhập login với class component</p>\n<h3 id=\"tip-tối-ưu-performance-bằng-cách-bỏ-qua-effect-tip-optimizing-performance-by-skipping-effects\"><a href=\"#tip-t%E1%BB%91i-%C6%B0u-performance-b%E1%BA%B1ng-c%C3%A1ch-b%E1%BB%8F-qua-effect-tip-optimizing-performance-by-skipping-effects\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tip: Tối ưu Performance bằng cách bỏ qua Effect {#tip-optimizing-performance-by-skipping-effects}</h3>\n<p>Trong một số trường hợp, clean và apply effect sau khi render có thể dẫn đến ảnh hưởng performance. Trong class component, chúng ta giải quyết bằng viết một hàm so sánh giữa <code class=\"language-text\">prevProps</code> hoặc <code class=\"language-text\">prevState</code> bên trong <code class=\"language-text\">componentDidUpdate</code>:</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps<span class=\"token punctuation\">,</span> prevState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevState<span class=\"token punctuation\">.</span><span class=\"token property-access\">count</span> <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">state</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">count</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">title</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">You clicked </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">state</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">count</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> times</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Đây là yêu cầu rất cần thiết, nên đã được có đưa sẵn trong <code class=\"language-text\">useEffect</code> Hook API. Bạn có thể bảo React <em>bỏ qua</em> việc apply effect nếu một số giá trị không thay đổi giữa các lần render. Để làm như vậy, truyền vào một array (không bắt buộc) vào <code class=\"language-text\">useEffect</code>:</p>\n<pre class=\"language-js{3}\"><code class=\"language-js{3}\">useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // Chỉ re-run effect nếu giá trị count thay đổi</code></pre>\n<p>Trong ví dụ ở trên, chúng ta truyền vào <code class=\"language-text\">[count]</code> như một tham số thứ 2. Nó nghĩa là gì? Nếu <code class=\"language-text\">count</code> là <code class=\"language-text\">5</code>, rồi sau đó component re-render với <code class=\"language-text\">count</code> vẫn bằng <code class=\"language-text\">5</code>, React sẽ so sánh <code class=\"language-text\">[5]</code> từ lần render trước và <code class=\"language-text\">[5]</code> với lần render hiện tại. Vì tất cả giá trị trong mảng bằng nhau (<code class=\"language-text\">5 === 5</code>), React sẽ bỏ qua  effect. Đó là cách chúng ta tối ưu</p>\n<p>Khi chúng ta render với <code class=\"language-text\">count</code> thành <code class=\"language-text\">6</code>, React sẽ so sánh các giá trị trong <code class=\"language-text\">[5]</code> từ lần render trước với các giá trị trong <code class=\"language-text\">[6]</code> lần render hiện tại. Ở lần này, React sẽ gọi lại effect vì <code class=\"language-text\">5 !== 6</code>. Nếu có nhiều giá trị bên trong array, React sẽl re-run effect nếu một trong các giá trị đó khác với lần trước.</p>\n<p>Effect cũng làm việc tương tự với quá trình cleanup:</p>\n<pre class=\"language-js{10}\"><code class=\"language-js{10}\">useEffect(() => {\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n}, [props.friend.id]); // Chỉ re-subscribe nếu props.friend.id bị thay đổi</code></pre>\n<p>Trong tương lai, tham số thứ 2 sẽ được tự động thêm vào trong lúc  build-transform.</p>\n<blockquote>\n<p>Lưu ý</p>\n<p>Nếu sử dụng cách tối ưu này, phải chắc chắn array chứa <strong>tất cả giá trị bên trong của component scope (như prop và state) nếu thay đổi theo các lần render và effect có sử dụng</strong>. Nếu không, nếu không nó sẽ tham chiếu tới giá trị trước đó. Đọc thêm <a href=\"http://vi.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">làm việc với function</a> và <a href=\"http://vi.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">làm gì khi array thay đổi thường xuyên</a>.</p>\n<p>Nếu muốn chạy 1 effect và clean nó 1 lần duy nhất (lúc mount và unmount), bạn có thể truyền vào array rỗng (<code class=\"language-text\">[]</code>). Đồng nghĩa với việc bạn báo với React, effect này không phụ thuộc <em>bất kỳ</em> giá trị nào của prop hoặc state, do đó không bao giờ cần re-run. Nó không phải là một trường hợp  được xử lý đặc biệt -- nó đúng với cách so sánh array hiện tại</p>\n<p>Nếu truyền vào array rỗng (<code class=\"language-text\">[]</code>), prop và state bên trong effect sẽ luôn mang giá trị khởi tạo. Trong khi truyền vào <code class=\"language-text\">[]</code> nó gần giống với <code class=\"language-text\">componentDidMount</code> và <code class=\"language-text\">componentWillUnmount</code>, nó thường là <a href=\"http://vi.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">giải pháp</a> <a href=\"http://vi.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tốt hơn</a> để tránh re-run effect quá thường xuyên. Tuy nhiên, đừng quên React sẽ chỉ chạy <code class=\"language-text\">useEffect</code> sau khi trình duyệt paint.</p>\n<p>Chúng tôi khuyến khích sử dụng <a href=\"https://github.com/facebook/react/issues/14920\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">đưa tất cả dependency</code></a>, sử dụng  <a href=\"https://www.npmjs.com/package/eslint-plugin-react-hooks#installation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">eslint-plugin-react-hooks</code></a> package để ràng buộc, và thông báo nếu khai báo dependency không hợp lệ.</p>\n</blockquote>\n<h2 id=\"bước-tiếp-theo-next-steps\"><a href=\"#b%C6%B0%E1%BB%9Bc-ti%E1%BA%BFp-theo-next-steps\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Bước tiếp theo {#next-steps}</h2>\n<p>Xin chúc mừng! Trang này không hề ngắn, nhưng bạn đã đọc được đến đây. Hy vọng các thắc mắc của bạn về effect đã được phúc đáp. Bạn đã học được State Hook và Effect Hook, và có <em>rất</em> nhiều thứ bạn có thể làm khi sử dụng kết hợp chúng.  Nó gần như giải quyết các vấn đề mà chỉ có class mới làm được -- còn nếu không bạn có thể tìm thấy <a href=\"http://vi.reactjs.org/docs/hooks-reference.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">các Hook mở rộng</a>.</p>\n<p>Chúng ta đã trình bài động lực tạo ra Hook <a href=\"http://vi.reactjs.org/docs/hooks-intro.html#motivation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ở đây</a>. Chúng ta cũng thấy được cách  effect cleanup và tránh trùng lặp trong <code class=\"language-text\">componentDidUpdate</code> và <code class=\"language-text\">componentWillUnmount</code>, mang những đoạn code có liên quan lại gần nhau hơn, và giúp chúng ta tránh bug. Chúng ta cũng thấy được cách chúng ta tách effect theo mục đích, cái mà chúng ta không làm được với class.</p>\n<p>Đến đây, bạn có thể thắc mắc Hook làm việc như thế nào. Làm cách nào <code class=\"language-text\">useState</code> lấy được đúng giá trị giữa các lần render khác nhau? Làm cách nào React \"match\" được effect trước và lần đang update? <strong>Ở trang tiếp theo bạn sẽ học được <a href=\"http://vi.reactjs.org/docs/hooks-rules.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Quy luật của Hook</a> -- mấu chốt làm việc của Hook.</strong></p>\n","cover_image":"","related":[{"id":"77a81e0c87ac4c028e3855b09ed9acca","path":"/lam-sao-de-fetch-du-lieu-bang-react-hook/","title":"Làm sao để fetch dữ liệu bằng React Hook","desc":"Trong bài này chúng ta sẽ sử dụng React.useState, React.useEffect, React.useReducer để fetch dữ liệu từ API, đồng thời cũng viết một custom hook để có thể sử dụng ở bất kỳ đâu"},{"id":"12b2cd38bed043dbfa473bf29abfdeb6","path":"/su-dung-react-lazy-ra-lam-sao/","title":"Sử dụng React.lazy ra làm sao?","desc":"Api mới của React 16.6"},{"id":"67335fb1f2a382145c69b99fe4e01d34","path":"/su-dung-react-context-nhu-the-nao-cho-hieu-qua/","title":"Sử dụng React Context như thế nào cho hiệu quả","desc":"Để có thể quản lý được state của ứng dụng một cách tốt nhất, chúng ta cần sự phân chia phù hợp giữa local state (internal state của component) và state cửa ứng dụng đặt trong React Context. Một vài điều muốn chia sẽ để nâng cao khả năng bảo trì và trải nghiệm nếu sử dụng đến context trong React."},{"id":"34e1a6e4e7dac657edca4c9832d737dc","path":"/su-dung-tabindex/","title":"Sử dụng tabindex","desc":"Mặc định thứ tự tab theo vị trí của DOM rất hữu dụng, tuy nhiên có trường hợp chúng ta sẽ muốn thay đổi thứ tự tab này. Cùng nghiên cứu tabindex để set thứ tự tab"}]}},"context":{}}