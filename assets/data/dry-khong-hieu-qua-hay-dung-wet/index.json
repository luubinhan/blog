{"hash":"bb9d7e5a46c25f220b2fd3c7f9d26cdf170dba2b","data":{"post":{"title":"DRY không hiệu quả, hãy dùng WET","path":"/dry-khong-hieu-qua-hay-dung-wet/","date":"2020-08-24","timeToRead":2,"tags":[{"id":"javascript","title":"javascript","path":"/tag/javascript/"},{"id":"hoc-thuat","title":"hoc-thuat","path":"/tag/hoc-thuat/"}],"desc":"Khi bạn học lập trình bạn sẽ được nghe tới khái niệm DRY (Don't Repeat Yourself), bạn rất có thể đã vận dụng sai ý nghĩa của nó.","content":"<p>Trên wiki: DRY là nguyên tắc bạn đừng viết lặp lại một đoạn code</p>\n<p>Bạn: Ok, những phần code bị trùng mình sẽ chuyển thành abstraction</p>\n<p>Giải pháp trông có vẻ hiển nhiên đúng, nhưng không, abstraction của bạn thường là sai.</p>\n<p>Đây là lý do tại sao:</p>\n<ol>\n<li>Bạn thấy code bị duplicate</li>\n<li>Bạn đưa đoạn duplicate ra thành một abstract (method, class)</li>\n<li>Bạn thay thể toàn bộ phần duplicate bằng abstraction mới</li>\n<li>Bạn nghĩ code đã hoàn hảo</li>\n<li>Thời gian trôi đi</li>\n<li>PM đưa thêm các yêu cầu mới.</li>\n<li>Bạn bắt đầu hiện thực các yêu cầu mới</li>\n<li>Với yêu cầu mới này, bạn phải chỉnh sửa vài đoạn trong abstraction, <code class=\"language-text\">if...else</code> các kiểu, đổi parameter, abstraction của chúng ta có thể đưa ra những action khác nhau theo những điều kiện khác nhau</li>\n<li>Giờ abstraction của trọng sẽ cho ra những kết quả khác nhau trên những case khác nhau</li>\n<li>Yêu cầu mới lại đến, thêm parameter tiếp, thêm câu điều kiện tiếp</li>\n<li>Và giờ đây đoạn code của bạn không còn dễ maintain, nói thẳng ra là một đống hầm bà lằng khó nuốt</li>\n<li>Chúc mừng, bạn đã bị over engineer và gây ra một abstract quá đỗi phức tạp</li>\n</ol>\n<p>Vậy thì sao? Hãy thử WET (Write everything twice)</p>\n<h2 id=\"wet\"><a href=\"#wet\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>WET</h2>\n<p>Như cách chơi chữ đã thể hiện, nó là trường phái đối nghịch hoàn toàn với DRY, khi bắt đầu viết code, bạn sẽ không thể nào lường trước được mọi yêu cầu, mọi tính năng. Vì thế đừng vội vàng áp dụng abstraction</p>\n<p>Bạn hãy nhớ</p>\n<blockquote>\n<p>Cái giá phải trả cho duplicate vẫn rẻ hơn nhiều cho một abstract viết sai</p>\n</blockquote>\n<p>Ví dụ bạn viết một ứng dụng, bạn dựng ra một component tên <code class=\"language-text\">Button</code> để sử dụng nhiều nơi, nghe rất hợp lý. Một yêu cầu mới xuất hiện, ở trang landing page họ muốn có một nút bấm rất <em>fancy</em> và không giống với tất cả những nút bấm trước đây.</p>\n<p>Ok, thay đổi cũng nhỏ thôi, chỉ cần thêm tí điều kiện <code class=\"language-text\">if...else</code>, 90% phần code là của <code class=\"language-text\">Button</code> và 10% code là của <code class=\"language-text\">FancyButton</code></p>\n<p>Sự thật đáng buồn là sẽ có rất nhiều những thay đổi như thế xuất hiện và khả năng rất cao là bạn không đủ kinh nghiệm để có hiện thực những abstraction đủ dễ hiểu, dễ maintain.</p>\n<p>Lời khuyên? <strong>Copy copy code đó ra, đừng ngần ngại</strong></p>\n<p>Bạn thấy quan điểm của mình <em>bậy quá bậy!</em>, bạn có thể tham khảo thêm quan điểm của Dan Abramov</p>\n<p><a href=\"https://overreacted.io/the-wet-codebase/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The WET Codebase</a></p>\n<blockquote>\n<p>In this talk, my aim was to show why strict adherence to writing code that is free of duplication inevitably leads to software we can’t understand</p>\n</blockquote>\n<p>Tạm dịch, tuân thủ nghiêm ngặc quy tắc DRY sẽ dẫn đến một phần mềm mà chúng ta không hiểu nổi nó.</p>\n<p><a href=\"https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Watch: The Wet Codebase</a></p>\n<p><a href=\"https://dev.to/bulljsdev/when-dry-doesn-t-work-go-wet-4536\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">When DRY Doesn't Work, Go WET - Tác giả Nick Bull JS</a></p>\n","cover_image":""}},"context":{}}