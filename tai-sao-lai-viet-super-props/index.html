<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Tại sao lại viết Super(props) - VuiLapTrinh.com</title><meta name="gridsome:hash" content="caea05e5fffa0cfcd138bf0521c438fe71931a82"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.21"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Tutorials, Blog, Hướng dẫn, chia sẽ kinh nghiệm về Frontend, react, vue, ux, ui"><meta data-vue-tag="ssr" name="desc" content="Bài cũ, dịch cũng lâu rồi, giờ mới đăng lên trang cá nhân của mình"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/assets/css/0.styles.6e7bce94.css" as="style"><link rel="preload" href="/assets/js/app.51940451.js" as="script"><link rel="preload" href="/assets/js/page--src-templates-post-vue.8b234962.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules-gridsome-app-pages-404-vue.1906fe28.js"><link rel="prefetch" href="/assets/js/page--src-pages-index-vue.771b03bf.js"><link rel="prefetch" href="/assets/js/page--src-templates-tag-vue.77b6aec4.js"><link rel="stylesheet" href="/assets/css/0.styles.6e7bce94.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← VuiLapTrinh.com
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><div class="post-title"><h1 class="post-title__text">Tại sao lại viết Super(props)</h1><div class="post-meta">
  Đăng ngày 2019-11-10.
  
    Mất khoảng
    <strong>5 phút</strong> để đọc.
  </div></div><div class="post content-box"><div class="post__header"><!----></div><div class="post__content"><p>Nghe nói <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="nofollow noopener noreferrer">Hook</a> đang là trend. Trớ trêu thay, tôi muốn viết bài đầu tiên cho blog này để nói về điều thú vị của <em>class</em> component.</p>
<p><strong>Vấn đề này <em>không</em> liên quan tới việc sử dụng React một cách hiệu quả. Nhưng bạn sẽ cảm thấy chúng thú vị nếu như bạn muốn tìm hiểu sâu hơn về cách hoạt động.</strong></p>
<p>Đây là bài đầu tiên.</p>
<hr>
<p>Chúng ta đã viết <code class="language-text">super(props)</code> không biết bao nhiêu lần trong đời:</p>
<pre class="language-jsx{3}"><code class="language-jsx{3}">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}</code></pre>
<p>Dĩ nhiên, nếu áp dụng <a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="nofollow noopener noreferrer">class field proposal</a> thì có thể bỏ qua <em>nghi thức</em> này:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Checkbox</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
<p>Cú pháp này <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers" target="_blank" rel="nofollow noopener noreferrer">đã  được hoạch định</a> khi React 0.13 đã hỗ trợ cho plain class năm 2015. KHai báo <code class="language-text">constructor</code> và gọi <code class="language-text">super(props)</code> luôn là kế hoạch tạm thời cho đến khi có một cách khác tốt hơn.</p>
<p>Quay về ví dụ,  chỉ sử dụng các tính năng của ES2015:</p>
<pre class="language-jsx{3}"><code class="language-jsx{3}">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}</code></pre>
<p><strong>Tại sao chúng ta lại gọi <code class="language-text">super</code>? Chúng ta có thể <em>không</em> gọi chúng được không? Nếu chúng ta gọi chúng, thì chuyện gì sẽ xảy ra nếu chúng ta không truyền <code class="language-text">props</code>? Truyền thêm các tham số khác được không?</strong> Cùng tìm hiểu nào.</p>
<hr>
<p>Trong JavaScript, <code class="language-text">super</code> để gọi lại constructor của class cha. (Trong ví dụ của chúng ta, nó trỏ về <code class="language-text">React.Component</code>.)</p>
<p>Điều quan trọng, bạn <strong>không thể sử dụng <code class="language-text">this</code></strong> trong constructor nếu chưa gọi đến constructor của class cha. JavaScript sẽ không để bạn làm việc này:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Checkbox</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 🔴  Không thể dùng `this` được</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ✅  Giờ thì dùng được rồi</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
<p>Có một lý do chính đáng giải thích vì sao JavaScript phải thực hiện constructor của lớp cha trước khi đụng vào <code class="language-text">this</code>. Hãy xem xét trường hợp sau:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">PolitePerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴  Điều này không cho phép, đọc lý do ở bên dưới</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Chào buổi sáng!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Hãy tưởng tượng, khi bạn có thể dùng <code class="language-text">this</code> trước <code class="language-text">super</code>. Một tháng sau, chúng ta đổi <code class="language-text">greetColleagues</code>, thêm <code class="language-text">this.name</code> khi alert:</p>
<pre class="language-jsx"><code class="language-jsx">  <span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Chào buổi sáng!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Tên tôi là '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">+</span> <span class="token string">', rất vui được gặp bạn!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<p>Nhưng chúng ta quên rằng <code class="language-text">this.greetColleagues()</code> được gọi trước <code class="language-text">super()</code>, giá trị <code class="language-text">this.name</code> <strong>chỉ có sau khi gọi <code class="language-text">super()</code></strong>! Lúc này bạn có thể thấy, code như thế này khó để biết được lỗi ở đâu.</p>
<p>Để tránh những điều như vậy, <strong>JavaScript chỉ định rằng nếu bạn muốn sử dụng <code class="language-text">this</code> bên trong constructor, bạn <em>phải</em> gọi <code class="language-text">super</code> trước.</strong> Để cho thằng cha làm việc của nó! Và điều này cũng áp dụng với các lớp React components:</p>
<pre class="language-jsx"><code class="language-jsx">  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ✅  Okay, dùng `this` được rồi</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<p>Chúng ta cùng đến với câu hỏi khác: phải sao phải truyền vào <code class="language-text">props</code>?</p>
<hr>
<p>Bạn hãy nghĩ đơn giản rằng khi truyền <code class="language-text">props</code> vào <code class="language-text">super</code> là cần thiết để <code class="language-text">React.Component</code> constructor có thể thiết lập <code class="language-text">this.props</code>:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token comment">// Bên trong React</span>
<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Nó thật sự là <a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22" target="_blank" rel="nofollow noopener noreferrer">cách mà chúng tôi thực hiện bên trong React.Component</a>.</p>
<p>Bằng cách nào đó, nếu bạn gọi <code class="language-text">super()</code> mà không có tham số <code class="language-text">props</code>, bạn vẫn có thể sử dụng <code class="language-text">this.props</code> trong phương thức <code class="language-text">render</code> và các phương thức khác. (Nếu không tin, hãy tự kiểm tra xem!)</p>
<p>Vậy <em>nó</em> hoạt động như thế nào? Hóa ra <strong>React đã gán <code class="language-text">props</code> cho một instance ngay sau constructor:</strong></p>
<pre class="language-jsx"><code class="language-jsx">  <span class="token comment">// Bên trong React</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YourComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  instance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span></code></pre>
<p>Thế nên khi bạn quên bỏ thằng <code class="language-text">props</code> vào <code class="language-text">super()</code>, thì trong React bạn vẫn có thể gọi nó sau đó. Có một lý do cho việc này.</p>
<p>Khi React hỗ trợ thêm class, nó không chỉ hỗ trợ class cho mỗi phiên bản ES6. Mà mục tiêu chính là hỗ trợ nhiều class abstract nhất có thể. <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages" target="_blank" rel="nofollow noopener noreferrer">Không rõ</a> làm thế nào ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript, hoặc các giải pháp khác định nghĩa component. Vì vậy, React sử dụng <code class="language-text">super()</code> không hề là quan điểm cá nhân.</p>
<p>Vậy có nghĩa là bạn có thể gọi <code class="language-text">super()</code> thay vì <code class="language-text">super(props)</code>?</p>
<p><strong>Không. Như vậy rất khó hiểu.</strong> Chắc chắn, React sẽ gán <code class="language-text">this.props</code> <em>sau khi</em>  constructor chạy. Nhưng <code class="language-text">this.props</code> vẫn  là <code class="language-text">undefined</code> <em>giữa</em> lúc gọi <code class="language-text">super</code> và kết thúc constructor:</p>
<pre class="language-jsx{14}"><code class="language-jsx{14}">// Bên trong React
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}

// Bên trong code của bạn
class Button extends React.Component {
  constructor(props) {
    super(); // 😬 Chúng ta không truyền vào props
    console.log(props);      // ✅ {}
    console.log(this.props); // 😬 undefined - chưa định nghĩa 
  }
  // ...
}</code></pre>
<p>Việc debug sẽ trở nên khó khăn nếu như một vài phương thức được gọi <em>từ</em> constructor. <strong>Đó là lý do vì sao luôn khuyến khích bạn sử dụng <code class="language-text">super(props)</code>, mặc dù nó không phải quy định bắt buộc:</strong></p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Chúng ta truyền props vào </span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// ✅ {}</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ {}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
<p>Điều này đảm bảo <code class="language-text">this.props</code> sẽ được thiết lập trong constructor.</p>
<hr>
<p>Có một điều cuối mà khiến cho các fan lâu năm của React tò mò.</p>
<p>Bạn có thể thấy rằng khi sử dụng Context API bên trong class (hoặc với <code class="language-text">contextTypes</code> cũ hoặc với <code class="language-text">contextType</code> API được thêm vào ở React 16.6), <code class="language-text">context</code> được đẩy vào tham số thứ hai trong constructor.</p>
<p>Vậy tại sao chúng ta không viết là <code class="language-text">super(props, context)</code>? Có thể chứ, nhưng context ít khi sử dụng nên việc phát sinh lỗi cũng ít xuất hiện.</p>
<p><strong>Với <a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="nofollow noopener noreferrer">class fields proposal</a> thì những vấn đề này hầu như biến mất.</strong> Không có constructor, tất cả các tham số đều được truyền vào một cách tự động. Đây là những lý do cho phép một biểu thức <code class="language-text">state = {}</code> bao gồm cả các tham chiếu <code class="language-text">this.props</code> hoặc <code class="language-text">this.context</code> nếu cần thiết.</p>
<p>Với Hooks, chúng ta thậm chí không có <code class="language-text">super</code> hoặc <code class="language-text">this</code>. Nhưng chủ đề đó sẽ giành cho một ngày khác.</p>
<p><strong>Bài viết được dịch từ</strong> <a target="_blank" rel="noopener noreferrer" href="https://overreacted.io/why-do-we-write-super-props/">Why Do We Write super(props)?</a></p>
</div><div class="post__footer"><div class="post-tags"><a href="/tag/hoc-thuat/" class="post-tags__link"><span>#</span> hoc-thuat
		</a><a href="/tag/javascript/" class="post-tags__link"><span>#</span> javascript
		</a><a href="/tag/react/" class="post-tags__link"><span>#</span> react
		</a></div></div></div><div class="post-comments"></div><div class="author post-author"><img alt="Author image" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 180 180' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-52311ff214b737f722259e901102d6b3'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='5'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-52311ff214b737f722259e901102d6b3)' width='180' height='180' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABAAEADASIAAhEBAxEB/8QAHAAAAQUBAQEAAAAAAAAAAAAABwEDBAUGCAAC/8QAMxAAAQMCAwcBBgYDAAAAAAAAAQIDEQAEBRIhBhMxQVFhcQciIzJCgbEIFDORodEWgsH/xAAZAQEBAQEBAQAAAAAAAAAAAAAEAwUGAAH/xAAhEQABBAMAAgMBAAAAAAAAAAABAAIDEQQSISJBBRNRMf/aAAwDAQACEQMRAD8A6Pr1fOalmvLyUAk6AnxS5VROUx4oR%2bvmPXNjZYbhti48DcKUt9LRIJAHsgkaxMmO1ByzxnG8PeQ/a3d5bOIIUVJdUOHMifvWjB8c6aMP2q0CfPbC/TW119SVz9YetmOMLYRfWWH3TaSA4pKVNrWOuhgH6UYtkNrsK2stFvYU65nbjesOpyrbnhPIjuKhPhSwDZw4qw5kU5ph6r%2blpCYFNOLKflV5o1JSXMkDlS5xy1qtDo4mfrWe2/xhWEbJ3t400%2b6oZWyGpkBRiTGoSNJj/tVbEXEN/VMyAC1iPUTaS2xjG3bO3IS3ay2HNJc1lR6xPDx3oa4g0RvVlQcSfhFRLrEF3V0LpSAh10layOMzw7eKl3jqLhxsxLaRw4610MUYiAa1ZMxMosrPugpJJ0nlwiiJ%2bH69eZ28NulfuX7R0LTOhygKB8yKxWLaWoC0BJKpgfL2rdfh8sV3G1F9iBTLNnalGbkFuEADzAVVMpwOO6/xCx4izJaAuiSsT8UV8KKyBznmKih1J714OqIiCa5jVdJsqk4ggL9oRPSqDbty4/w/GnLVzKPyypBkaEif4p5N2RwA/anlPtvsrafAW0tJStChKVA8QR0p4ZqQQil1ilz5Y5nGloXKkcNev908G8iUoSCUiiHtVhFhhdou6wu2O6JyuNg/pzwUCdY5a8JrAXtwErWi3RmIEZwZE9utaccm/QEVzKVZjVrltN4JyJMqFdGemuz7OzmyFjbBGS5eQLm6PMuLAMf6iE/SgBavuMPNOON75wKC0tr4GDPtdqO%2bxm0i8ew0O3O7RfJnett6J4mCnXhH81DNDzGK/i%2b4/wBbZSb7S1xQ2IIVBHWvb2BAIioBcVxMCml3KgYFZQZadtSzAK460hCpkk%2bBTzahmmnXnRA0APmadsj0ol1uE2T6r5SEWgbO9K%2bARGs0H7stto3luczSyS3mEKUJIBI66VrvUnGWlJZwlKsuaHnjmgafCk/f9qwD6y%2b2pbjhKU%2bylWaJ8dabjxmtne0HInolrVcYThj18w5clKzl1KOZ/sVLRtJ%2bQbQ7akpum/01oEA9c3bvULB8WtGbRYuW1vvBOVtTivm48eVUt9Z3dwpKlIbaZIhJQZEdJq7fJxDxxHcdWgxnvtFbZz1ItsQCWMWyWb8hJcn3ZV3Pyz14eK2e9WpUBJoGYHhVpmCQyCtTZBMaHz1oq7DYxvmBh11IeZT7pR%2bZA5eR9vFCyoGs8owm4sz38kK//9k=' /%3e%3c/svg%3e" width="180" data-src="/assets/static/author.e6b6009.95c26cbf81b488daf3af4259c9393a66.jpg" data-srcset="/assets/static/author.e6b6009.95c26cbf81b488daf3af4259c9393a66.jpg 180w" data-sizes="(max-width: 180px) 100vw, 180px" class="author__image g-image g-image--lazy g-image--loading"><noscript><img src="/assets/static/author.e6b6009.95c26cbf81b488daf3af4259c9393a66.jpg" class="author__image g-image g-image--loaded" width="180" alt="Author image"></noscript><!----><p class="author__intro">Hiện tại site đang nâng cấp, các bạn xài tạm</p></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2020.</span><span class="footer__links">luckyluu</span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"Tại sao lại viết Super(props)","path":"\u002Ftai-sao-lai-viet-super-props\u002F","date":"2019-11-10","timeToRead":5,"tags":[{"id":"hoc-thuat","title":"hoc-thuat","path":"\u002Ftag\u002Fhoc-thuat\u002F"},{"id":"javascript","title":"javascript","path":"\u002Ftag\u002Fjavascript\u002F"},{"id":"react","title":"react","path":"\u002Ftag\u002Freact\u002F"}],"desc":"Bài cũ, dịch cũng lâu rồi, giờ mới đăng lên trang cá nhân của mình","content":"\u003Cp\u003ENghe nói \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Fhooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EHook\u003C\u002Fa\u003E đang là trend. Trớ trêu thay, tôi muốn viết bài đầu tiên cho blog này để nói về điều thú vị của \u003Cem\u003Eclass\u003C\u002Fem\u003E component.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EVấn đề này \u003Cem\u003Ekhông\u003C\u002Fem\u003E liên quan tới việc sử dụng React một cách hiệu quả. Nhưng bạn sẽ cảm thấy chúng thú vị nếu như bạn muốn tìm hiểu sâu hơn về cách hoạt động.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EĐây là bài đầu tiên.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003EChúng ta đã viết \u003Ccode class=\"language-text\"\u003Esuper(props)\u003C\u002Fcode\u003E không biết bao nhiêu lần trong đời:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx{3}\"\u003E\u003Ccode class=\"language-jsx{3}\"\u003Eclass Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  \u002F\u002F ...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EDĩ nhiên, nếu áp dụng \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Eclass field proposal\u003C\u002Fa\u003E thì có thể bỏ qua \u003Cem\u003Enghi thức\u003C\u002Fem\u003E này:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cspan class=\"token keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003ECheckbox\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EReact\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003EComponent\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  state \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E isOn\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token boolean\"\u003Etrue\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F ...\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ECú pháp này \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fblog\u002F2015\u002F01\u002F27\u002Freact-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Eđã  được hoạch định\u003C\u002Fa\u003E khi React 0.13 đã hỗ trợ cho plain class năm 2015. KHai báo \u003Ccode class=\"language-text\"\u003Econstructor\u003C\u002Fcode\u003E và gọi \u003Ccode class=\"language-text\"\u003Esuper(props)\u003C\u002Fcode\u003E luôn là kế hoạch tạm thời cho đến khi có một cách khác tốt hơn.\u003C\u002Fp\u003E\n\u003Cp\u003EQuay về ví dụ,  chỉ sử dụng các tính năng của ES2015:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx{3}\"\u003E\u003Ccode class=\"language-jsx{3}\"\u003Eclass Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  \u002F\u002F ...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003ETại sao chúng ta lại gọi \u003Ccode class=\"language-text\"\u003Esuper\u003C\u002Fcode\u003E? Chúng ta có thể \u003Cem\u003Ekhông\u003C\u002Fem\u003E gọi chúng được không? Nếu chúng ta gọi chúng, thì chuyện gì sẽ xảy ra nếu chúng ta không truyền \u003Ccode class=\"language-text\"\u003Eprops\u003C\u002Fcode\u003E? Truyền thêm các tham số khác được không?\u003C\u002Fstrong\u003E Cùng tìm hiểu nào.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003ETrong JavaScript, \u003Ccode class=\"language-text\"\u003Esuper\u003C\u002Fcode\u003E để gọi lại constructor của class cha. (Trong ví dụ của chúng ta, nó trỏ về \u003Ccode class=\"language-text\"\u003EReact.Component\u003C\u002Fcode\u003E.)\u003C\u002Fp\u003E\n\u003Cp\u003EĐiều quan trọng, bạn \u003Cstrong\u003Ekhông thể sử dụng \u003Ccode class=\"language-text\"\u003Ethis\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E trong constructor nếu chưa gọi đến constructor của class cha. JavaScript sẽ không để bạn làm việc này:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cspan class=\"token keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003ECheckbox\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EReact\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003EComponent\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token function\"\u003Econstructor\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Eprops\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token comment\"\u003E\u002F\u002F 🔴  Không thể dùng `this` được\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Esuper\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Eprops\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token comment\"\u003E\u002F\u002F ✅  Giờ thì dùng được rồi\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Estate\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E isOn\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token boolean\"\u003Etrue\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F ...\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ECó một lý do chính đáng giải thích vì sao JavaScript phải thực hiện constructor của lớp cha trước khi đụng vào \u003Ccode class=\"language-text\"\u003Ethis\u003C\u002Fcode\u003E. Hãy xem xét trường hợp sau:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cspan class=\"token keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EPerson\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token function\"\u003Econstructor\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Ename\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Ename\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E name\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"token keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EPolitePerson\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EPerson\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token function\"\u003Econstructor\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Ename\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003EgreetColleagues\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F 🔴  Điều này không cho phép, đọc lý do ở bên dưới\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Esuper\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Ename\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token function\"\u003EgreetColleagues\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token function\"\u003Ealert\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'Chào buổi sáng!'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHãy tưởng tượng, khi bạn có thể dùng \u003Ccode class=\"language-text\"\u003Ethis\u003C\u002Fcode\u003E trước \u003Ccode class=\"language-text\"\u003Esuper\u003C\u002Fcode\u003E. Một tháng sau, chúng ta đổi \u003Ccode class=\"language-text\"\u003EgreetColleagues\u003C\u002Fcode\u003E, thêm \u003Ccode class=\"language-text\"\u003Ethis.name\u003C\u002Fcode\u003E khi alert:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E  \u003Cspan class=\"token function\"\u003EgreetColleagues\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token function\"\u003Ealert\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'Chào buổi sáng!'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token function\"\u003Ealert\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'Tên tôi là '\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E+\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Ename\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E+\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E', rất vui được gặp bạn!'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ENhưng chúng ta quên rằng \u003Ccode class=\"language-text\"\u003Ethis.greetColleagues()\u003C\u002Fcode\u003E được gọi trước \u003Ccode class=\"language-text\"\u003Esuper()\u003C\u002Fcode\u003E, giá trị \u003Ccode class=\"language-text\"\u003Ethis.name\u003C\u002Fcode\u003E \u003Cstrong\u003Echỉ có sau khi gọi \u003Ccode class=\"language-text\"\u003Esuper()\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E! Lúc này bạn có thể thấy, code như thế này khó để biết được lỗi ở đâu.\u003C\u002Fp\u003E\n\u003Cp\u003EĐể tránh những điều như vậy, \u003Cstrong\u003EJavaScript chỉ định rằng nếu bạn muốn sử dụng \u003Ccode class=\"language-text\"\u003Ethis\u003C\u002Fcode\u003E bên trong constructor, bạn \u003Cem\u003Ephải\u003C\u002Fem\u003E gọi \u003Ccode class=\"language-text\"\u003Esuper\u003C\u002Fcode\u003E trước.\u003C\u002Fstrong\u003E Để cho thằng cha làm việc của nó! Và điều này cũng áp dụng với các lớp React components:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E  \u003Cspan class=\"token function\"\u003Econstructor\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Eprops\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Esuper\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Eprops\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token comment\"\u003E\u002F\u002F ✅  Okay, dùng `this` được rồi\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Estate\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E isOn\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token boolean\"\u003Etrue\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EChúng ta cùng đến với câu hỏi khác: phải sao phải truyền vào \u003Ccode class=\"language-text\"\u003Eprops\u003C\u002Fcode\u003E?\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003EBạn hãy nghĩ đơn giản rằng khi truyền \u003Ccode class=\"language-text\"\u003Eprops\u003C\u002Fcode\u003E vào \u003Ccode class=\"language-text\"\u003Esuper\u003C\u002Fcode\u003E là cần thiết để \u003Ccode class=\"language-text\"\u003EReact.Component\u003C\u002Fcode\u003E constructor có thể thiết lập \u003Ccode class=\"language-text\"\u003Ethis.props\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cspan class=\"token comment\"\u003E\u002F\u002F Bên trong React\u003C\u002Fspan\u003E\n\u003Cspan class=\"token keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EComponent\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token function\"\u003Econstructor\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Eprops\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Eprops\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E props\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token comment\"\u003E\u002F\u002F ...\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ENó thật sự là \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002F1d25aa5787d4e19704c049c3cfa985d3b5190e0d\u002Fpackages\u002Freact\u002Fsrc\u002FReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecách mà chúng tôi thực hiện bên trong React.Component\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EBằng cách nào đó, nếu bạn gọi \u003Ccode class=\"language-text\"\u003Esuper()\u003C\u002Fcode\u003E mà không có tham số \u003Ccode class=\"language-text\"\u003Eprops\u003C\u002Fcode\u003E, bạn vẫn có thể sử dụng \u003Ccode class=\"language-text\"\u003Ethis.props\u003C\u002Fcode\u003E trong phương thức \u003Ccode class=\"language-text\"\u003Erender\u003C\u002Fcode\u003E và các phương thức khác. (Nếu không tin, hãy tự kiểm tra xem!)\u003C\u002Fp\u003E\n\u003Cp\u003EVậy \u003Cem\u003Enó\u003C\u002Fem\u003E hoạt động như thế nào? Hóa ra \u003Cstrong\u003EReact đã gán \u003Ccode class=\"language-text\"\u003Eprops\u003C\u002Fcode\u003E cho một instance ngay sau constructor:\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E  \u003Cspan class=\"token comment\"\u003E\u002F\u002F Bên trong React\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Econst\u003C\u002Fspan\u003E instance \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EYourComponent\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Eprops\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  instance\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Eprops\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E props\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThế nên khi bạn quên bỏ thằng \u003Ccode class=\"language-text\"\u003Eprops\u003C\u002Fcode\u003E vào \u003Ccode class=\"language-text\"\u003Esuper()\u003C\u002Fcode\u003E, thì trong React bạn vẫn có thể gọi nó sau đó. Có một lý do cho việc này.\u003C\u002Fp\u003E\n\u003Cp\u003EKhi React hỗ trợ thêm class, nó không chỉ hỗ trợ class cho mỗi phiên bản ES6. Mà mục tiêu chính là hỗ trợ nhiều class abstract nhất có thể. \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fblog\u002F2015\u002F01\u002F27\u002Freact-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EKhông rõ\u003C\u002Fa\u003E làm thế nào ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript, hoặc các giải pháp khác định nghĩa component. Vì vậy, React sử dụng \u003Ccode class=\"language-text\"\u003Esuper()\u003C\u002Fcode\u003E không hề là quan điểm cá nhân.\u003C\u002Fp\u003E\n\u003Cp\u003EVậy có nghĩa là bạn có thể gọi \u003Ccode class=\"language-text\"\u003Esuper()\u003C\u002Fcode\u003E thay vì \u003Ccode class=\"language-text\"\u003Esuper(props)\u003C\u002Fcode\u003E?\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EKhông. Như vậy rất khó hiểu.\u003C\u002Fstrong\u003E Chắc chắn, React sẽ gán \u003Ccode class=\"language-text\"\u003Ethis.props\u003C\u002Fcode\u003E \u003Cem\u003Esau khi\u003C\u002Fem\u003E  constructor chạy. Nhưng \u003Ccode class=\"language-text\"\u003Ethis.props\u003C\u002Fcode\u003E vẫn  là \u003Ccode class=\"language-text\"\u003Eundefined\u003C\u002Fcode\u003E \u003Cem\u003Egiữa\u003C\u002Fem\u003E lúc gọi \u003Ccode class=\"language-text\"\u003Esuper\u003C\u002Fcode\u003E và kết thúc constructor:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx{14}\"\u003E\u003Ccode class=\"language-jsx{14}\"\u003E\u002F\u002F Bên trong React\nclass Component {\n  constructor(props) {\n    this.props = props;\n    \u002F\u002F ...\n  }\n}\n\n\u002F\u002F Bên trong code của bạn\nclass Button extends React.Component {\n  constructor(props) {\n    super(); \u002F\u002F 😬 Chúng ta không truyền vào props\n    console.log(props);      \u002F\u002F ✅ {}\n    console.log(this.props); \u002F\u002F 😬 undefined - chưa định nghĩa \n  }\n  \u002F\u002F ...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EViệc debug sẽ trở nên khó khăn nếu như một vài phương thức được gọi \u003Cem\u003Etừ\u003C\u002Fem\u003E constructor. \u003Cstrong\u003EĐó là lý do vì sao luôn khuyến khích bạn sử dụng \u003Ccode class=\"language-text\"\u003Esuper(props)\u003C\u002Fcode\u003E, mặc dù nó không phải quy định bắt buộc:\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre class=\"language-jsx\"\u003E\u003Ccode class=\"language-jsx\"\u003E\u003Cspan class=\"token keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EButton\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Eextends\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EReact\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003EComponent\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token function\"\u003Econstructor\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Eprops\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Esuper\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Eprops\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F ✅ Chúng ta truyền props vào \u003C\u002Fspan\u003E\n    \u003Cspan class=\"token console class-name\"\u003Econsole\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Elog\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Eprops\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E      \u003Cspan class=\"token comment\"\u003E\u002F\u002F ✅ {}\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token console class-name\"\u003Econsole\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Elog\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Eprops\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F ✅ {}\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F ...\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EĐiều này đảm bảo \u003Ccode class=\"language-text\"\u003Ethis.props\u003C\u002Fcode\u003E sẽ được thiết lập trong constructor.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003ECó một điều cuối mà khiến cho các fan lâu năm của React tò mò.\u003C\u002Fp\u003E\n\u003Cp\u003EBạn có thể thấy rằng khi sử dụng Context API bên trong class (hoặc với \u003Ccode class=\"language-text\"\u003EcontextTypes\u003C\u002Fcode\u003E cũ hoặc với \u003Ccode class=\"language-text\"\u003EcontextType\u003C\u002Fcode\u003E API được thêm vào ở React 16.6), \u003Ccode class=\"language-text\"\u003Econtext\u003C\u002Fcode\u003E được đẩy vào tham số thứ hai trong constructor.\u003C\u002Fp\u003E\n\u003Cp\u003EVậy tại sao chúng ta không viết là \u003Ccode class=\"language-text\"\u003Esuper(props, context)\u003C\u002Fcode\u003E? Có thể chứ, nhưng context ít khi sử dụng nên việc phát sinh lỗi cũng ít xuất hiện.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EVới \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Eclass fields proposal\u003C\u002Fa\u003E thì những vấn đề này hầu như biến mất.\u003C\u002Fstrong\u003E Không có constructor, tất cả các tham số đều được truyền vào một cách tự động. Đây là những lý do cho phép một biểu thức \u003Ccode class=\"language-text\"\u003Estate = {}\u003C\u002Fcode\u003E bao gồm cả các tham chiếu \u003Ccode class=\"language-text\"\u003Ethis.props\u003C\u002Fcode\u003E hoặc \u003Ccode class=\"language-text\"\u003Ethis.context\u003C\u002Fcode\u003E nếu cần thiết.\u003C\u002Fp\u003E\n\u003Cp\u003EVới Hooks, chúng ta thậm chí không có \u003Ccode class=\"language-text\"\u003Esuper\u003C\u002Fcode\u003E hoặc \u003Ccode class=\"language-text\"\u003Ethis\u003C\u002Fcode\u003E. Nhưng chủ đề đó sẽ giành cho một ngày khác.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EBài viết được dịch từ\u003C\u002Fstrong\u003E \u003Ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https:\u002F\u002Foverreacted.io\u002Fwhy-do-we-write-super-props\u002F\"\u003EWhy Do We Write super(props)?\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n","cover_image":""}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.51940451.js" defer></script><script src="/assets/js/page--src-templates-post-vue.8b234962.js" defer></script>
  </body>
</html>